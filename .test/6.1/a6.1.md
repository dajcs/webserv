I'll help you implement Step 6.1: Response Generation. Looking at your existing code, I can see you already have a good foundation in `Response.hpp` and `Response.cpp`. Let me analyze what's already implemented and what needs to be added or improved. 

Read [](file:///home/anemet/webserv/src/Response.cpp#1-1), lines 1 to 250

Read [](file:///home/anemet/webserv/inc/Response.hpp#1-1), lines 1 to 180

Read [](file:///home/anemet/webserv/src/Response.cpp#250-250), lines 250 to 445

Now I have a complete picture. Your `Response` class is well-implemented! I'll enhance it with:

1. **Missing headers** as per Step 6.1 (Date, Server headers)
2. **More comprehensive error pages**
3. **Complete unit tests** that work without the network layer

Here are the enhanced files:

## Enhanced Response.hpp

````cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Response.hpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anemet <anemet@student.42luxembourg.lu>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/07 15:57:21 by anemet            #+#    #+#             */
/*   Updated: 2025/12/11 15:59:35 by anemet           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef RESPONSE_HPP
#define RESPONSE_HPP

#include <string>
#include <map>
#include <sstream>
#include <ctime>

/*
	=================================
		HTTP RESPONSE BASICS
	=================================

	An HTTP response is what the server sends back to the client (browser).
	It consists of three parts:

	1. STATUS LINE: HTTP version + status code + reason phrase
	   Example: "HTTP/1.1 200 OK"

	2. HEADERS: Key-value pairs with metadata about the response
	   Example: "Content-Type: text/html"

	3. BODY: The actual content (HTML, JSON, image data, etc.)
	   Example: "<html><body>Hello</body></html>"

	These parts are separated by CRLF (\r\n):

	HTTP/1.1 200 OK\r\n
	Content-Type: text/html\r\n
	Content-Length: 42\r\n
	Date: Wed, 11 Dec 2025 12:00:00 GMT\r\n
	Server: webserv/1.0\r\n
	Connection: keep-alive\r\n
	\r\n                              <- Empty line marks end of headers
	<html><body>Hello World</body></html>

	Why is this format important?
	- HTTP is a text-based protocol with strict formatting rules
	- Browsers expect exact format; any deviation causes parsing failures
	- \r\n (CRLF) is MANDATORY, not just \n
*/

class Response
{

	private:
		int _statusCode;                              // HTTP status code (200, 404, 500, etc.)
		std::string _reasonPhrase;                    // Human-readable status ("OK", "Not Found")
		std::map<std::string, std::string> _headers;  // HTTP headers (key -> value)
		std::string _body;                            // Response body content
		mutable std::string _builtResponse;           // Cached complete HTTP response string
		mutable bool _dirty;                          // Flag: does response need rebuilding?
		bool _keepAlive;                              // Should connection stay open?

		// Lazy building pattern - only rebuild when needed
		void buildIfNeeded() const;


	public:
		// ===== Constructors & Destructor =====
		Response();
		~Response();
		Response(const Response& other);
		Response& operator=(const Response& other);

		// ===== Setters for response components =====
		void setStatus(int code);
		void setStatus(int code, const std::string& reason);
		void setHeader(const std::string& name, const std::string& value);
		void setBody(const std::string& body);
		void setBody(const char* data, size_t length);

		// ===== Convenience methods for common headers =====
		void setContentType(const std::string& type);
		void setContentLength(size_t length);
		void setConnection(bool keepAlive);

		// ===== Standard headers (Step 6.1 requirement) =====
		void addDateHeader();      // Add current date/time
		void addServerHeader();    // Add "Server: webserv/1.0"
		void addStandardHeaders(); // Add all standard headers at once

		// ===== Building the response =====
		std::string build() const;
		const std::string& getData() const;
		size_t getSize() const;

		// ===== Getters =====
		int getStatusCode() const;
		const std::string& getBody() const;
		const std::string& getReasonPhraseValue() const;
		std::string getHeader(const std::string& name) const;
		bool hasHeader(const std::string& name) const;
		bool shouldKeepAlive() const;

		// ===== Static factory methods for common responses =====
		static Response ok(const std::string& body, const std::string& contentType = "text/html");
		static Response error(int code);
		static Response error(int code, const std::string& customBody);
		static Response redirect(int code, const std::string& location);
		static Response noContent();  // 204 No Content (for DELETE success)

		// ===== Static helpers =====
		static std::string getReasonPhrase(int code);
		static std::string getMimeType(const std::string& extension);
		static std::string getDefaultErrorPage(int code);
		static std::string formatHttpDate(time_t timestamp);
};

#endif
````

## Enhanced Response.cpp

````cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Response.cpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anemet <anemet@student.42luxembourg.lu>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/07 15:55:39 by anemet            #+#    #+#             */
/*   Updated: 2025/12/11 16:49:21 by anemet           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Response.hpp"
#include <sstream>
#include <ctime>
#include <cstring>


/*
	=================================
		RESPONSE OVERVIEW
	=================================

	The Response class encapsulates an HTTP response that we send back to clients.

	HTTP Response Structure (RFC 7230):
	-----------------------------------
	HTTP/1.1 200 OK                          <- Status Line
	Date: Wed, 11 Dec 2025 12:00:00 GMT      <- Date header (recommended)
	Server: webserv/1.0                      <- Server identification
	Content-Type: text/html                  <- MIME type of body
	Content-Length: 1234                     <- Size of body in bytes
	Connection: keep-alive                   <- Connection handling
	                                         <- Empty line (CRLF)
	<html>                                   <- Body
	<body>Hello World</body>
	</html>

	Status Line Components:
	- HTTP Version: HTTP/1.1 (we support both 1.0 and 1.1)
	- Status Code: 3-digit numeric code (200, 404, 500, etc.)
	- Reason Phrase: Human-readable description ("OK", "Not Found")

	Status Code Categories:
	- 1xx Informational: Request received, continuing process
	- 2xx Success:   200 OK, 201 Created, 204 No Content
	- 3xx Redirect:  301 Moved Permanently, 302 Found, 304 Not Modified
	- 4xx Client Error: 400 Bad Request, 403 Forbidden, 404 Not Found
	- 5xx Server Error: 500 Internal Server Error, 502 Bad Gateway

	Required Headers for HTTP/1.1:
	- Content-Length OR Transfer-Encoding: chunked (to know body size)
	- Date: Current server time (recommended by RFC)
	- Server: Identifies the server software (optional but common)
	- Content-Type: MIME type (critical for browser rendering)
	- Connection: keep-alive or close (controls TCP connection)

	Why correct formatting matters:
	- Browsers are strict about HTTP format
	- Missing CRLF (\r\n) breaks parsing completely
	- Incorrect Content-Length causes hangs or truncation
	- Wrong Content-Type makes browsers misinterpret data
*/



// ================================
//  Constructors and Destructors
// ================================

/*
	Default Constructor

	Creates a response with sensible defaults:
	- Status: 200 OK (success)
	- Keep-Alive: true (for HTTP/1.1 connection reuse)
	- Dirty flag: true (needs building before sending)

	The "dirty" pattern:
	We don't build the full HTTP string immediately. Instead, we mark
	the response as "dirty" when modified, then build it only when
	needed (lazy evaluation). This is efficient for responses that
	are modified multiple times before sending.
*/
Response::Response() :
	_statusCode(200),
	_reasonPhrase("OK"),
	_dirty(true),
	_keepAlive(true)
{}

/*
	Destructor

	Nothing to clean up - all members use RAII (strings, maps)
	C++98 doesn't require explicit cleanup for standard containers
*/
Response::~Response() {}

/*
	Copy Constructor

	Deep copy of all response data. Needed for returning Response
	objects by value (common pattern in our router).

	Example:
		Response Router::route(Request& req) {
			Response res;
			res.setStatus(200);
			return res;  // Copy constructor called here
		}
*/
Response::Response(const Response& other) :
	_statusCode(other._statusCode),
	_reasonPhrase(other._reasonPhrase),
	_headers(other._headers),
	_body(other._body),
	_builtResponse(other._builtResponse),
	_dirty(other._dirty),
	_keepAlive(other._keepAlive)
{}

/*
	Copy Assignment Operator

	Handles assignment between existing Response objects.
	Self-assignment check prevents issues like: response = response;
*/
Response& Response::operator=(const Response& other)
{
	if (this != &other)
	{
		_statusCode = other._statusCode;
		_reasonPhrase = other._reasonPhrase;
		_headers = other._headers;
		_body = other._body;
		_builtResponse = other._builtResponse;
		_dirty = other._dirty;
		_keepAlive = other._keepAlive;
	}
	return *this;
}


// =======================
//  Setters
// =======================

/*
	setStatus() - Set HTTP status code

	Automatically looks up the standard reason phrase.
	Marks response as dirty so it will be rebuilt.

	Example:
		response.setStatus(404);
		// Result: "HTTP/1.1 404 Not Found"
*/
void Response::setStatus(int code)
{
	_statusCode = code;
	_reasonPhrase = getReasonPhrase(code);
	_dirty = true;
}

/*
	setStatus() - Set status with custom reason phrase

	Allows non-standard reason phrases if needed.
	HTTP spec says reason phrase can be anything,
	but standard phrases improve compatibility.

	Example:
		response.setStatus(420, "Enhance Your Calm");
*/
void Response::setStatus(int code, const std::string& reason)
{
	_statusCode = code;
	_reasonPhrase = reason;
	_dirty = true;
}

/*
	setHeader() - Add or update an HTTP header

	Headers are case-sensitive in our implementation
	(technically case-insensitive per HTTP spec, but most servers use exact case)

	Common headers:
		Content-Type: text/html
		Content-Length: 1234
		Location: /new-url (for redirects)
		Set-Cookie: session=xyz
		Cache-Control: no-cache

	Example:
		response.setHeader("Content-Type", "application/json");
		response.setHeader("X-Custom-Header", "custom-value");
*/
void Response::setHeader(const std::string& name, const std::string& value)
{
	_headers[name] = value;
	_dirty = true;
}

/*
	setBody() - Set response body from string

	The body contains the actual content being sent.
	Marks response as dirty so Content-Length will be recalculated.

	Example:
		response.setBody("<html><body>Hello</body></html>");
*/
void Response::setBody(const std::string& body)
{
	_body = body;
	_dirty = true;
}

/*
	setBody() - Set response body from raw data

	Used for binary data (images, files, etc.)
	String assign() handles binary data safely (no null termination issues)

	Example:
		char imageData[1024];
		int bytesRead = read(fd, imageData, 1024);
		response.setBody(imageData, bytesRead);
*/
void Response::setBody(const char* data, size_t length)
{
	_body.assign(data, length);
	_dirty = true;
}

/*
	setContentType() - Convenience method for Content-Type header

	Content-Type tells the browser how to interpret the body.
	This is CRITICAL - wrong type breaks rendering!

	Common types:
		text/html        - HTML pages
		text/css         - Stylesheets
		application/json - JSON data
		image/jpeg       - JPEG images
		application/octet-stream - Binary/unknown

	Example:
		response.setContentType("application/json");
*/
void Response::setContentType(const std::string& type)
{
	setHeader("Content-Type", type);
}

/*
	setContentLength() - Set Content-Length header

	Content-Length is the size of the body in bytes.
	HTTP/1.1 requires this for persistent connections.

	Without Content-Length:
	- Browser doesn't know when response ends
	- Connection must close after each response (inefficient)
	- Or must use chunked encoding (more complex)

	We auto-calculate this in build() if not set manually.
*/
void Response::setContentLength(size_t length)
{
	std::ostringstream ss;
	ss << length;
	setHeader("Content-Length", ss.str());
}

/*
	setConnection() - Set Connection header

	Connection: keep-alive - Keep TCP connection open for next request
	Connection: close      - Close connection after this response

	HTTP/1.1 keep-alive benefits:
	- Reuse TCP connection (avoid 3-way handshake overhead)
	- Faster subsequent requests
	- Lower CPU/memory usage

	When to use close:
	- Server overloaded (limit concurrent connections)
	- Error conditions
	- Client sent HTTP/1.0 without Connection: keep-alive
*/
void Response::setConnection(bool keepAlive)
{
	_keepAlive = keepAlive;
	setHeader("Connection", keepAlive ? "keep-alive" : "close");
}


// ================================
//  Standard Headers (Step 6.1)
// ================================

/*
	formatHttpDate() - Format timestamp as HTTP date string

	HTTP/1.1 uses a specific date format (RFC 7231):
	"Wed, 11 Dec 2025 12:00:00 GMT"

	This format is:
	- Day name (3 chars), comma, space
	- Day (2 digits), space
	- Month name (3 chars), space
	- Year (4 digits), space
	- Time (HH:MM:SS), space
	- "GMT" (always GMT, never local time)

	Why GMT?
	HTTP is a global protocol. Using local time would cause confusion
	between servers and clients in different timezones. GMT provides
	a universal reference point.
*/
std::string Response::formatHttpDate(time_t timestamp)
{
	struct tm* gmt = gmtime(&timestamp);
	if (!gmt)
	{
		return "Thu, 01 Jan 1970 00:00:00 GMT"; // Fallback to epoch
	}

	// Day and month names as required by HTTP date format
	static const char* days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	static const char* months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
									"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

	std::ostringstream ss;
	ss << days[gmt->tm_wday] << ", ";

	// Day with leading zero if needed
	if (gmt->tm_mday < 10)
		ss << "0";
	ss << gmt->tm_mday << " ";

	ss << months[gmt->tm_mon] << " ";
	ss << (1900 + gmt->tm_year) << " ";

	// Time with leading zeros
	if (gmt->tm_hour < 10)
		ss << "0";
	ss << gmt->tm_hour << ":";
	if (gmt->tm_min < 10)
		ss << "0";
	ss << gmt->tm_min << ":";
	if (gmt->tm_sec < 10)
		ss << "0";
	ss << gmt->tm_sec << " GMT";

	return ss.str();
}

/*
	addDateHeader() - Add current date/time header

	The Date header indicates when the response was generated.
	This is useful for:
	- Caching (determining if content is fresh)
	- Logging and debugging
	- Time synchronization

	RFC 7231 recommends including Date in all responses.
*/
void Response::addDateHeader()
{
	setHeader("Date", formatHttpDate(time(NULL)));
}

/*
	addServerHeader() - Add server identification header

	The Server header identifies the server software.
	Example: "Server: webserv/1.0"

	This is optional but common. It helps:
	- Debugging (what server is responding?)
	- Statistics (what servers are popular?)
	- Security research (identifying vulnerable versions)

	Note: Some security-conscious servers omit this header
	or use a generic value to prevent fingerprinting.
*/
void Response::addServerHeader()
{
	setHeader("Server", "webserv/1.0");
}

/*
	addStandardHeaders() - Add all standard headers at once

	Convenience method that adds:
	- Date: Current server time
	- Server: Server identification
	- Connection: Based on keep-alive setting

	Call this before building the response to ensure
	all recommended headers are present.
*/
void Response::addStandardHeaders()
{
	addDateHeader();
	addServerHeader();
	setConnection(_keepAlive);
}


// ===============================
//  Building the Response
// ===============================

/*
	buildIfNeeded() - Lazy build pattern

	Only rebuilds the HTTP response string if it's been modified.
	This is efficient when response is tweaked multiple times.

	HTTP Response Format (RFC 7230):
		Status-Line CRLF
		*(Header-Field CRLF)
		CRLF
		[ message-body ]

	CRLF = \r\n (Carriage Return + Line Feed)
	- Critical: HTTP requires \r\n, not just \n
	- Browser will reject responses with wrong line endings
*/
void Response::buildIfNeeded() const
{
	if (!_dirty)
	{
		return;
	}

	std::ostringstream ss;

	/*
		STATUS LINE
		Format: HTTP-Version SP Status-Code SP Reason-Phrase CRLF

		Example: "HTTP/1.1 200 OK\r\n"

		Components:
		- HTTP/1.1: Protocol version (we always use 1.1)
		- 200: Status code (3-digit number)
		- OK: Reason phrase (human-readable, optional in HTTP/2+)
	*/
	ss << "HTTP/1.1 " << _statusCode << " " << _reasonPhrase << "\r\n";

	/*
		HEADERS
		Format: Header-Name: Header-Value CRLF

		Each header on its own line, colon-space between name and value.
		Order doesn't matter (mostly), but consistency helps debugging.
	*/
	for (std::map<std::string, std::string>::const_iterator it = _headers.begin();
		it != _headers.end(); ++it)
	{
		ss << it->first << ": " << it->second << "\r\n";
	}

	/*
		AUTO-ADD Content-Length if not manually set

		Content-Length is essential for HTTP/1.1:
		- Tells browser exactly how many bytes to expect
		- Enables persistent connections (keep-alive)
		- Without it, browser doesn't know when body ends

		Exception: 204 No Content responses shouldn't have Content-Length
	*/
	if (_headers.find("Content-Length") == _headers.end() && _statusCode != 204)
	{
		ss << "Content-Length: " << _body.size() << "\r\n";
	}

	/*
		END OF HEADERS
		Empty line (just CRLF) separates headers from body
		This is CRITICAL - missing empty line breaks HTTP parsing
	*/
	ss << "\r\n";

	/*
		BODY
		The actual content being sent.
		Can be text (HTML, JSON) or binary (images, files).
		Size must match Content-Length header exactly.
	*/
	ss << _body;

	_builtResponse = ss.str();
	_dirty = false;
}

/*
	build() - Get the complete HTTP response as a string

	Returns the full HTTP response ready to send via send().

	Example output:
		"HTTP/1.1 200 OK\r\n"
		"Date: Wed, 11 Dec 2025 12:00:00 GMT\r\n"
		"Server: webserv/1.0\r\n"
		"Content-Type: text/html\r\n"
		"Content-Length: 42\r\n"
		"Connection: keep-alive\r\n"
		"\r\n"
		"<html><body>Hello World</body></html>"
*/
std::string Response::build() const
{
	buildIfNeeded();
	return _builtResponse;
}

/*
	getData() - Get reference to built response

	More efficient than build() - returns const reference
	instead of copying the string. Use this when sending
	data through send() or write().
*/
const std::string& Response::getData() const
{
	buildIfNeeded();
	return _builtResponse;
}

/*
	getSize() - Get total response size in bytes

	Useful for:
	- Progress tracking during send()
	- Bandwidth calculations
	- Logging
	- Debugging
*/
size_t Response::getSize() const
{
	buildIfNeeded();
	return _builtResponse.size();
}


// ==============================
//  Getters
// ==============================

int Response::getStatusCode() const
{
	return _statusCode;
}

const std::string& Response::getBody() const
{
	return _body;
}

const std::string& Response::getReasonPhraseValue() const
{
	return _reasonPhrase;
}

/*
	getHeader() - Get a specific header value

	Returns the header value if found, empty string otherwise.
	Useful for testing and debugging.
*/
std::string Response::getHeader(const std::string& name) const
{
	std::map<std::string, std::string>::const_iterator it = _headers.find(name);
	if (it != _headers.end())
	{
		return it->second;
	}
	return "";
}

/*
	hasHeader() - Check if a header exists

	Returns true if the header is set, false otherwise.
*/
bool Response::hasHeader(const std::string& name) const
{
	return _headers.find(name) != _headers.end();
}

bool Response::shouldKeepAlive() const
{
	return _keepAlive;
}


// ===============================
//  Static Factory Methods
// ===============================

/*
	ok() - Quick factory for 200 OK responses

	Convenience method for common case of successful response.

	Example:
		return Response::ok("<html>Success!</html>");

	Instead of:
		Response res;
		res.setStatus(200);
		res.setContentType("text/html");
		res.setBody("<html>Success!</html>");
		return res;
*/
Response Response::ok(const std::string& body, const std::string& contentType)
{
	Response response;
	response.setStatus(200);
	response.setContentType(contentType);
	response.setBody(body);
	response.addStandardHeaders();
	return response;
}

/*
	getDefaultErrorPage() - Generate HTML for error page

	Creates a simple, clean error page with:
	- Error code and reason in title
	- Large heading with error code
	- Server identification

	This is used when no custom error page is configured.
*/
std::string Response::getDefaultErrorPage(int code)
{
	std::ostringstream body;
	body << "<!DOCTYPE html>\n";
	body << "<html>\n";
	body << "<head>\n";
	body << "    <meta charset=\"UTF-8\">\n";
	body << "    <title>" << code << " " << getReasonPhrase(code) << "</title>\n";
	body << "    <style>\n";
	body << "        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }\n";
	body << "        h1 { font-size: 50px; color: #333; }\n";
	body << "        p { color: #666; }\n";
	body << "        hr { border: none; border-top: 1px solid #ddd; margin: 20px 0; }\n";
	body << "    </style>\n";
	body << "</head>\n";
	body << "<body>\n";
	body << "    <h1>" << code << "</h1>\n";
	body << "    <p>" << getReasonPhrase(code) << "</p>\n";
	body << "    <hr>\n";
	body << "    <p><small>webserv/1.0</small></p>\n";
	body << "</body>\n";
	body << "</html>\n";
	return body.str();
}

/*
	error() - Create a default error response

	Generates a complete error response with:
	- Appropriate status code and reason phrase
	- Default HTML error page
	- All standard headers
*/
Response Response::error(int code)
{
	Response response;
	response.setStatus(code);
	response.setContentType("text/html; charset=UTF-8");
	response.setBody(getDefaultErrorPage(code));
	response.addStandardHeaders();
	return response;
}

/*
	error() - Create error response with custom body

	Allows custom error pages (configured per-server).
	Use this when the config specifies a custom error page.
*/
Response Response::error(int code, const std::string& customBody)
{
	Response response;
	response.setStatus(code);
	response.setContentType("text/html; charset=UTF-8");
	response.setBody(customBody);
	response.addStandardHeaders();
	return response;
}

/*
	redirect() - Create a redirect response

	HTTP redirects tell the browser to go to a different URL.

	Common redirect codes:
	- 301 Moved Permanently: URL has permanently changed (cached)
	- 302 Found: Temporary redirect (not cached)
	- 303 See Other: Redirect after POST (use GET)
	- 307 Temporary Redirect: Keep original method
	- 308 Permanent Redirect: Keep original method, permanent

	The Location header contains the new URL.
	Body contains fallback HTML for clients that don't follow redirects.
*/
Response Response::redirect(int code, const std::string& location)
{
	Response response;
	response.setStatus(code);
	response.setHeader("Location", location);
	response.setContentType("text/html; charset=UTF-8");

	std::ostringstream body;
	body << "<!DOCTYPE html>\n";
	body << "<html>\n";
	body << "<head>\n";
	body << "    <meta charset=\"UTF-8\">\n";
	body << "    <title>Redirect</title>\n";
	body << "    <meta http-equiv=\"refresh\" content=\"0; url=" << location << "\">\n";
	body << "</head>\n";
	body << "<body>\n";
	body << "    <h1>Redirecting...</h1>\n";
	body << "    <p>If you are not redirected automatically, ";
	body << "<a href=\"" << location << "\">click here</a>.</p>\n";
	body << "</body>\n";
	body << "</html>\n";

	response.setBody(body.str());
	response.addStandardHeaders();
	return response;
}

/*
	noContent() - Create a 204 No Content response

	Used for successful operations that don't return content.
	Typical use: DELETE method (file deleted successfully).

	204 responses:
	- MUST NOT have a body
	- MUST NOT have Content-Length header (or it should be 0)
	- Still include standard headers (Date, Server)
*/
Response Response::noContent()
{
	Response response;
	response.setStatus(204, "No Content");
	response.addStandardHeaders();
	// No body, no Content-Length for 204
	return response;
}


// ===============================
//  Static Helpers
// ===============================

/*
	getReasonPhrase() - Get standard reason phrase for status code

	HTTP status codes have standard reason phrases defined in RFCs.
	While the phrase is technically optional (and ignored by HTTP/2+),
	it helps with debugging and log readability.

	We support all common status codes that webserv might use.
*/
std::string Response::getReasonPhrase(int code)
{
	switch (code)
	{
		// 2xx Success
		case 200: return "OK";
		case 201: return "Created";
		case 204: return "No Content";

		// 3xx Redirection
		case 301: return "Moved Permanently";
		case 302: return "Found";
		case 303: return "See Other";
		case 304: return "Not Modified";
		case 307: return "Temporary Redirect";
		case 308: return "Permanent Redirect";

		// 4xx Client Errors
		case 400: return "Bad Request";
		case 403: return "Forbidden";
		case 404: return "Not Found";
		case 405: return "Method Not Allowed";
		case 408: return "Request Timeout";
		case 409: return "Conflict";
		case 411: return "Length Required";
		case 413: return "Payload Too Large";
		case 414: return "URI Too Long";
		case 415: return "Unsupported Media Type";

		// 5xx Server Errors
		case 500: return "Internal Server Error";
		case 501: return "Not Implemented";
		case 502: return "Bad Gateway";
		case 503: return "Service Unavailable";
		case 504: return "Gateway Timeout";
		case 505: return "HTTP Version Not Supported";

		default:  return "Unknown";
	}
}

/*
	getMimeType() - Get MIME type from file extension

	MIME types (Media Types) tell the browser how to handle content.
	Without correct MIME type, browser might:
	- Download instead of display HTML
	- Show garbled text for binary files
	- Refuse to execute JavaScript

	Format: type/subtype (e.g., "text/html", "image/png")

	Security note: Always set Content-Type explicitly.
	Browser "sniffing" can cause security issues.
*/
std::string Response::getMimeType(const std::string& extension)
{
	// Text types
	if (extension == ".html" || extension == ".htm")
		return "text/html; charset=UTF-8";
	if (extension == ".css")
		return "text/css; charset=UTF-8";
	if (extension == ".js")
		return "application/javascript; charset=UTF-8";
	if (extension == ".json")
		return "application/json; charset=UTF-8";
	if (extension == ".xml")
		return "application/xml; charset=UTF-8";
	if (extension == ".txt")
		return "text/plain; charset=UTF-8";

	// Image types
	if (extension == ".jpg" || extension == ".jpeg")
		return "image/jpeg";
	if (extension == ".png")
		return "image/png";
	if (extension == ".gif")
		return "image/gif";
	if (extension == ".ico")
		return "image/x-icon";
	if (extension == ".svg")
		return "image/svg+xml";
	if (extension == ".webp")
		return "image/webp";

	// Document types
	if (extension == ".pdf")
		return "application/pdf";
	if (extension == ".zip")
		return "application/zip";
	if (extension == ".gz" || extension == ".gzip")
		return "application/gzip";
	if (extension == ".tar")
		return "application/x-tar";

	// Media types
	if (extension == ".mp3")
		return "audio/mpeg";
	if (extension == ".mp4")
		return "video/mp4";
	if (extension == ".webm")
		return "video/webm";

	// Font types
	if (extension == ".woff")
		return "font/woff";
	if (extension == ".woff2")
		return "font/woff2";
	if (extension == ".ttf")
		return "font/ttf";

	// Default for unknown types
	// application/octet-stream tells browser to download, not display
	return "application/octet-stream";
}
````

## Unit Tests for Response Generation

Now let's create comprehensive unit tests that work without the network layer:

````cpp
/* ************************************************************************** */
/*                                                                            */
/*   test_response.cpp - Unit tests for Response Generation (Step 6.1)       */
/*                                                                            */
/* ************************************************************************** */

/*
	=================================
		TESTING WITHOUT NETWORK
	=================================

	Since the network layer isn't implemented yet, we test the Response class
	in isolation. This approach:

	1. Tests all response building logic directly
	2. Verifies HTTP format compliance
	3. Checks all status codes and headers
	4. Runs fast without socket overhead
	5. Is deterministic (no network timing issues)

	Testing Strategy:
	-----------------
	- Create Response objects using various methods
	- Build the response string
	- Parse/verify the built string contains expected components
	- Check HTTP format compliance (CRLF, headers, etc.)

	What We're Testing (Step 6.1 Requirements):
	------------------------------------------
	- Status line: "HTTP/1.1 STATUS_CODE REASON_PHRASE"
	- Standard headers: Content-Type, Content-Length, Date, Server, Connection
	- Response format: status line + headers + blank line + body
	- Default error pages for all error codes
*/

#include "Response.hpp"
#include <iostream>
#include <sstream>
#include <cstring>
#include <cstdlib>

// ===========================================
//  ANSI Color codes for pretty test output
// ===========================================
#define GREEN   "\033[32m"
#define RED     "\033[31m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define CYAN    "\033[36m"
#define RESET   "\033[0m"
#define BOLD    "\033[1m"

// Global test counters
static int g_passed = 0;
static int g_failed = 0;


// ===========================================
//  Test Helper Functions
// ===========================================

/*
	printTestHeader() - Display test section header
*/
void printTestHeader(const std::string& testName)
{
	std::cout << std::endl;
	std::cout << CYAN << BOLD << "═══════════════════════════════════════════" << RESET << std::endl;
	std::cout << CYAN << BOLD << "  " << testName << RESET << std::endl;
	std::cout << CYAN << BOLD << "═══════════════════════════════════════════" << RESET << std::endl;
}

/*
	assertTrue() - Assert a condition is true
*/
void assertTrue(bool condition, const std::string& testCase)
{
	if (condition)
	{
		std::cout << GREEN << "  ✓ PASS: " << testCase << RESET << std::endl;
		g_passed++;
	}
	else
	{
		std::cout << RED << "  ✗ FAIL: " << testCase << RESET << std::endl;
		g_failed++;
	}
}

/*
	assertEqual() - Assert two values are equal
*/
template<typename T>
void assertEqual(const T& actual, const T& expected, const std::string& testCase)
{
	if (actual == expected)
	{
		std::cout << GREEN << "  ✓ PASS: " << testCase << RESET << std::endl;
		g_passed++;
	}
	else
	{
		std::cout << RED << "  ✗ FAIL: " << testCase << RESET << std::endl;
		std::cout << RED << "    Expected: " << expected << RESET << std::endl;
		std::cout << RED << "    Actual:   " << actual << RESET << std::endl;
		g_failed++;
	}
}

/*
	assertContains() - Assert string contains substring
*/
void assertContains(const std::string& haystack, const std::string& needle,
					const std::string& testCase)
{
	if (haystack.find(needle) != std::string::npos)
	{
		std::cout << GREEN << "  ✓ PASS: " << testCase << RESET << std::endl;
		g_passed++;
	}
	else
	{
		std::cout << RED << "  ✗ FAIL: " << testCase << RESET << std::endl;
		std::cout << RED << "    String does not contain: \"" << needle << "\"" << RESET << std::endl;
		g_failed++;
	}
}

/*
	assertNotContains() - Assert string does NOT contain substring
*/
void assertNotContains(const std::string& haystack, const std::string& needle,
						const std::string& testCase)
{
	if (haystack.find(needle) == std::string::npos)
	{
		std::cout << GREEN << "  ✓ PASS: " << testCase << RESET << std::endl;
		g_passed++;
	}
	else
	{
		std::cout << RED << "  ✗ FAIL: " << testCase << RESET << std::endl;
		std::cout << RED << "    String should NOT contain: \"" << needle << "\"" << RESET << std::endl;
		g_failed++;
	}
}


// ===========================================
//  Test Cases: Status Line
// ===========================================

/*
	Test 1: Status Line Format

	HTTP responses MUST start with a status line:
	"HTTP/1.1 STATUS_CODE REASON_PHRASE\r\n"

	Examples:
	- "HTTP/1.1 200 OK\r\n"
	- "HTTP/1.1 404 Not Found\r\n"
*/
void testStatusLine()
{
	printTestHeader("STATUS LINE TESTS");

	// Test 200 OK
	{
		Response response;
		response.setStatus(200);
		std::string built = response.build();
		assertContains(built, "HTTP/1.1 200 OK\r\n", "200 OK status line");
	}

	// Test 404 Not Found
	{
		Response response;
		response.setStatus(404);
		std::string built = response.build();
		assertContains(built, "HTTP/1.1 404 Not Found\r\n", "404 Not Found status line");
	}

	// Test 500 Internal Server Error
	{
		Response response;
		response.setStatus(500);
		std::string built = response.build();
		assertContains(built, "HTTP/1.1 500 Internal Server Error\r\n", "500 status line");
	}

	// Test custom reason phrase
	{
		Response response;
		response.setStatus(418, "I'm a teapot");
		std::string built = response.build();
		assertContains(built, "HTTP/1.1 418 I'm a teapot\r\n", "Custom reason phrase");
	}
}


// ===========================================
//  Test Cases: Standard Headers
// ===========================================

/*
	Test 2: Content-Type Header

	Content-Type tells the browser how to interpret the response body.
	Without it, browsers may guess wrong (security risk!).
*/
void testContentTypeHeader()
{
	printTestHeader("CONTENT-TYPE HEADER TESTS");

	// Test HTML content type
	{
		Response response;
		response.setContentType("text/html");
		std::string built = response.build();
		assertContains(built, "Content-Type: text/html\r\n", "HTML content type");
	}

	// Test JSON content type
	{
		Response response;
		response.setContentType("application/json");
		std::string built = response.build();
		assertContains(built, "Content-Type: application/json\r\n", "JSON content type");
	}

	// Test via factory method
	{
		Response response = Response::ok("<html></html>", "text/html");
		std::string built = response.build();
		assertContains(built, "Content-Type: text/html\r\n", "Content-Type from ok() factory");
	}
}

/*
	Test 3: Content-Length Header

	Content-Length indicates the size of the body in bytes.
	Essential for HTTP/1.1 persistent connections.
*/
void testContentLengthHeader()
{
	printTestHeader("CONTENT-LENGTH HEADER TESTS");

	// Test auto-calculated Content-Length
	{
		Response response;
		response.setBody("Hello World");  // 11 bytes
		std::string built = response.build();
		assertContains(built, "Content-Length: 11\r\n", "Auto-calculated Content-Length");
	}

	// Test empty body
	{
		Response response;
		response.setBody("");
		std::string built = response.build();
		assertContains(built, "Content-Length: 0\r\n", "Content-Length for empty body");
	}

	// Test manual Content-Length
	{
		Response response;
		response.setContentLength(100);
		std::string built = response.build();
		assertContains(built, "Content-Length: 100\r\n", "Manual Content-Length");
	}

	// Test 204 No Content (should NOT have Content-Length)
	{
		Response response = Response::noContent();
		std::string built = response.build();
		assertNotContains(built, "Content-Length:", "204 No Content omits Content-Length");
	}
}

/*
	Test 4: Date Header

	Date header indicates when the response was generated.
	Format: "Date: Wed, 11 Dec 2025 12:00:00 GMT"
*/
void testDateHeader()
{
	printTestHeader("DATE HEADER TESTS");

	// Test Date header is added
	{
		Response response;
		response.addDateHeader();
		std::string built = response.build();
		assertContains(built, "Date: ", "Date header present");
		assertContains(built, " GMT\r\n", "Date header ends with GMT");
	}

	// Test addStandardHeaders includes Date
	{
		Response response;
		response.addStandardHeaders();
		std::string built = response.build();
		assertContains(built, "Date: ", "addStandardHeaders includes Date");
	}

	// Test formatHttpDate format
	{
		// January 1, 2025 00:00:00 GMT
		time_t testTime = 1735689600;
		std::string formatted = Response::formatHttpDate(testTime);
		// Should be "Wed, 01 Jan 2025 00:00:00 GMT"
		assertContains(formatted, "Jan 2025", "formatHttpDate contains month and year");
		assertContains(formatted, "GMT", "formatHttpDate contains GMT");
	}
}

/*
	Test 5: Server Header

	Server header identifies the server software.
	Example: "Server: webserv/1.0"
*/
void testServerHeader()
{
	printTestHeader("SERVER HEADER TESTS");

	// Test Server header is added
	{
		Response response;
		response.addServerHeader();
		std::string built = response.build();
		assertContains(built, "Server: webserv/1.0\r\n", "Server header present");
	}

	// Test addStandardHeaders includes Server
	{
		Response response;
		response.addStandardHeaders();
		std::string built = response.build();
		assertContains(built, "Server: webserv/1.0\r\n", "addStandardHeaders includes Server");
	}
}

/*
	Test 6: Connection Header

	Connection header controls whether the TCP connection stays open.
	- "Connection: keep-alive" - reuse connection for more requests
	- "Connection: close" - close connection after response
*/
void testConnectionHeader()
{
	printTestHeader("CONNECTION HEADER TESTS");

	// Test keep-alive (default)
	{
		Response response;
		response.setConnection(true);
		std::string built = response.build();
		assertContains(built, "Connection: keep-alive\r\n", "Connection keep-alive");
		assertTrue(response.shouldKeepAlive(), "shouldKeepAlive() returns true");
	}

	// Test close
	{
		Response response;
		response.setConnection(false);
		std::string built = response.build();
		assertContains(built, "Connection: close\r\n", "Connection close");
		assertTrue(!response.shouldKeepAlive(), "shouldKeepAlive() returns false");
	}
}


// ===========================================
//  Test Cases: Response Format
// ===========================================

/*
	Test 7: Complete Response Format

	HTTP response format:
	STATUS_LINE\r\n
	HEADER1: VALUE1\r\n
	HEADER2: VALUE2\r\n
	\r\n
	BODY
*/
void testResponseFormat()
{
	printTestHeader("RESPONSE FORMAT TESTS");

	// Test complete response structure
	{
		Response response;
		response.setStatus(200);
		response.setContentType("text/html");
		response.setBody("<html><body>Hello</body></html>");
		response.addStandardHeaders();
		std::string built = response.build();

		// Check status line comes first
		assertTrue(built.find("HTTP/1.1 200 OK\r\n") == 0, "Status line is first");

		// Check headers before body
		size_t headerEnd = built.find("\r\n\r\n");
		assertTrue(headerEnd != std::string::npos, "Headers end with blank line");

		// Check body comes after headers
		std::string body = built.substr(headerEnd + 4);
		assertContains(body, "<html><body>Hello</body></html>", "Body is after headers");
	}

	// Test CRLF line endings (not just \n)
	{
		Response response;
		response.setStatus(200);
		std::string built = response.build();
		assertContains(built, "\r\n", "Response uses CRLF line endings");
		assertNotContains(built.substr(0, 20), "\r\r", "No double CR");
	}

	// Test blank line separates headers from body
	{
		Response response;
		response.setBody("test body");
		std::string built = response.build();
		assertContains(built, "\r\n\r\ntest body", "Blank line before body");
	}
}


// ===========================================
//  Test Cases: Default Error Pages
// ===========================================

/*
	Test 8: Default Error Pages

	The server must have default error pages for all error codes.
	These are used when no custom error page is configured.
*/
void testDefaultErrorPages()
{
	printTestHeader("DEFAULT ERROR PAGES TESTS");

	// Common error codes to test
	int errorCodes[] = {400, 403, 404, 405, 413, 500, 501, 502, 504};
	int numCodes = sizeof(errorCodes) / sizeof(errorCodes[0]);

	for (int i = 0; i < numCodes; i++)
	{
		int code = errorCodes[i];
		Response response = Response::error(code);
		std::string built = response.build();

		std::ostringstream testName;
		testName << "Error " << code << " has valid status";
		assertEqual(response.getStatusCode(), code, testName.str());

		testName.str("");
		testName << "Error " << code << " has HTML body";
		assertContains(built, "<!DOCTYPE html>", testName.str());

		testName.str("");
		testName << "Error " << code << " shows error code in body";
		std::ostringstream codeStr;
		codeStr << code;
		assertContains(response.getBody(), codeStr.str(), testName.str());
	}

	// Test error page content
	{
		Response response = Response::error(404);
		std::string body = response.getBody();
		assertContains(body, "404", "404 error page shows code");
		assertContains(body, "Not Found", "404 error page shows reason");
		assertContains(body, "webserv", "Error page shows server name");
	}
}


// ===========================================
//  Test Cases: Factory Methods
// ===========================================

/*
	Test 9: Factory Methods

	Static factory methods for common response types:
	- Response::ok() for 200 OK
	- Response::error() for error responses
	- Response::redirect() for redirects
	- Response::noContent() for 204 No Content
*/
void testFactoryMethods()
{
	printTestHeader("FACTORY METHOD TESTS");

	// Test ok()
	{
		Response response = Response::ok("<p>Success</p>", "text/html");
		assertEqual(response.getStatusCode(), 200, "ok() returns 200 status");
		assertContains(response.getBody(), "Success", "ok() sets body");
		assertContains(response.build(), "Content-Type: text/html", "ok() sets content type");
	}

	// Test error()
	{
		Response response = Response::error(500);
		assertEqual(response.getStatusCode(), 500, "error() returns correct status");
		assertContains(response.build(), "Content-Type:", "error() sets content type");
		assertTrue(!response.getBody().empty(), "error() has body");
	}

	// Test redirect()
	{
		Response response = Response::redirect(301, "https://example.com/new");
		assertEqual(response.getStatusCode(), 301, "redirect() returns 301 status");
		assertContains(response.build(), "Location: https://example.com/new\r\n", 
					   "redirect() sets Location header");
		assertContains(response.getBody(), "example.com/new", "redirect() body has link");
	}

	// Test noContent()
	{
		Response response = Response::noContent();
		assertEqual(response.getStatusCode(), 204, "noContent() returns 204 status");
		assertTrue(response.getBody().empty(), "noContent() has no body");
	}
}


// ===========================================
//  Test Cases: MIME Types
// ===========================================

/*
	Test 10: MIME Type Detection

	getMimeType() should return correct Content-Type for file extensions.
*/
void testMimeTypes()
{
	printTestHeader("MIME TYPE TESTS");

	// HTML
	assertEqual(Response::getMimeType(".html"), std::string("text/html; charset=UTF-8"), 
				"MIME type for .html");
	assertEqual(Response::getMimeType(".htm"), std::string("text/html; charset=UTF-8"), 
				"MIME type for .htm");

	// CSS and JS
	assertEqual(Response::getMimeType(".css"), std::string("text/css; charset=UTF-8"), 
				"MIME type for .css");
	assertEqual(Response::getMimeType(".js"), std::string("application/javascript; charset=UTF-8"), 
				"MIME type for .js");

	// JSON
	assertEqual(Response::getMimeType(".json"), std::string("application/json; charset=UTF-8"), 
				"MIME type for .json");

	// Images
	assertEqual(Response::getMimeType(".png"), std::string("image/png"), "MIME type for .png");
	assertEqual(Response::getMimeType(".jpg"), std::string("image/jpeg"), "MIME type for .jpg");
	assertEqual(Response::getMimeType(".gif"), std::string("image/gif"), "MIME type for .gif");

	// Unknown extension
	assertEqual(Response::getMimeType(".xyz"), std::string("application/octet-stream"), 
				"MIME type for unknown extension");
}


// ===========================================
//  Test Cases: Reason Phrases
// ===========================================

/*
	Test 11: Reason Phrases

	Each status code should have a standard reason phrase.
*/
void testReasonPhrases()
{
	printTestHeader("REASON PHRASE TESTS");

	// 2xx Success
	assertEqual(Response::getReasonPhrase(200), std::string("OK"), "Reason for 200");
	assertEqual(Response::getReasonPhrase(201), std::string("Created"), "Reason for 201");
	assertEqual(Response::getReasonPhrase(204), std::string("No Content"), "Reason for 204");

	// 3xx Redirection
	assertEqual(Response::getReasonPhrase(301), std::string("Moved Permanently"), "Reason for 301");
	assertEqual(Response::getReasonPhrase(302), std::string("Found"), "Reason for 302");
	assertEqual(Response::getReasonPhrase(304), std::string("Not Modified"), "Reason for 304");

	// 4xx Client Errors
	assertEqual(Response::getReasonPhrase(400), std::string("Bad Request"), "Reason for 400");
	assertEqual(Response::getReasonPhrase(403), std::string("Forbidden"), "Reason for 403");
	assertEqual(Response::getReasonPhrase(404), std::string("Not Found"), "Reason for 404");
	assertEqual(Response::getReasonPhrase(405), std::string("Method Not Allowed"), "Reason for 405");
	assertEqual(Response::getReasonPhrase(413), std::string("Payload Too Large"), "Reason for 413");

	// 5xx Server Errors
	assertEqual(Response::getReasonPhrase(500), std::string("Internal Server Error"), "Reason for 500");
	assertEqual(Response::getReasonPhrase(502), std::string("Bad Gateway"), "Reason for 502");
	assertEqual(Response::getReasonPhrase(504), std::string("Gateway Timeout"), "Reason for 504");

	// Unknown
	assertEqual(Response::getReasonPhrase(999), std::string("Unknown"), "Reason for unknown code");
}


// ===========================================
//  Test Cases: Getters
// ===========================================

/*
	Test 12: Getter Methods
*/
void testGetters()
{
	printTestHeader("GETTER TESTS");

	Response response;
	response.setStatus(404);
	response.setHeader("X-Custom", "value123");
	response.setBody("test body content");
	response.setConnection(true);

	assertEqual(response.getStatusCode(), 404, "getStatusCode()");
	assertEqual(response.getBody(), std::string("test body content"), "getBody()");
	assertEqual(response.getHeader("X-Custom"), std::string("value123"), "getHeader() existing");
	assertEqual(response.getHeader("NonExistent"), std::string(""), "getHeader() non-existing");
	assertTrue(response.hasHeader("X-Custom"), "hasHeader() existing");
	assertTrue(!response.hasHeader("NonExistent"), "hasHeader() non-existing");
	assertTrue(response.shouldKeepAlive(), "shouldKeepAlive()");
}


// ===========================================
//  Test Cases: Copy Semantics
// ===========================================

/*
	Test 13: Copy Constructor and Assignment

	Responses are often returned by value from functions,
	so copy semantics must work correctly.
*/
void testCopySemantics()
{
	printTestHeader("COPY SEMANTICS TESTS");

	// Copy constructor
	{
		Response original;
		original.setStatus(201);
		original.setBody("original body");
		original.setHeader("X-Test", "test");

		Response copy(original);
		assertEqual(copy.getStatusCode(), 201, "Copy constructor copies status");
		assertEqual(copy.getBody(), std::string("original body"), "Copy constructor copies body");
		assertEqual(copy.getHeader("X-Test"), std::string("test"), "Copy constructor copies headers");

		// Modify original, copy should not change
		original.setStatus(500);
		assertEqual(copy.getStatusCode(), 201, "Copy is independent of original");
	}

	// Copy assignment
	{
		Response original;
		original.setStatus(202);
		original.setBody("assigned body");

		Response copy;
		copy = original;
		assertEqual(copy.getStatusCode(), 202, "Assignment copies status");
		assertEqual(copy.getBody(), std::string("assigned body"), "Assignment copies body");
	}

	// Self-assignment
	{
		Response response;
		response.setStatus(200);
		response.setBody("test");
		response = response;  // Self-assignment
		assertEqual(response.getStatusCode(), 200, "Self-assignment preserves status");
		assertEqual(response.getBody(), std::string("test"), "Self-assignment preserves body");
	}
}


// ===========================================
//  Test Cases: Binary Data
// ===========================================

/*
	Test 14: Binary Data Handling

	Response body can contain binary data (images, files).
	The Response class must handle null bytes correctly.
*/
void testBinaryData()
{
	printTestHeader("BINARY DATA TESTS");

	// Test body with null bytes
	{
		char binaryData[] = "hello\0world";  // 11 bytes including null
		Response response;
		response.setBody(binaryData, 11);

		assertEqual(response.getBody().size(), (size_t)11, "Binary body preserves size");
		assertContains(response.build(), "Content-Length: 11\r\n", "Content-Length for binary");
	}

	// Test setBody with char* and length
	{
		const char* data = "\x00\x01\x02\x03";
		Response response;
		response.setBody(data, 4);
		assertEqual(response.getBody().size(), (size_t)4, "setBody(char*, size) works");
	}
}


// ===========================================
//  Test Cases: Dirty Flag (Lazy Building)
// ===========================================

/*
	Test 15: Lazy Building / Dirty Flag

	The Response uses a "dirty" flag to avoid rebuilding
	the HTTP string unnecessarily.
*/
void testLazyBuilding()
{
	printTestHeader("LAZY BUILDING TESTS");

	Response response;
	response.setStatus(200);
	response.setBody("initial");

	// First build
	std::string first = response.build();
	assertContains(first, "initial", "First build has initial body");

	// Modify and rebuild
	response.setBody("modified");
	std::string second = response.build();
	assertContains(second, "modified", "Second build has modified body");
	assertNotContains(second, "initial", "Second build doesn't have old body");

	// Multiple builds without modification should return same result
	std::string third = response.build();
	assertEqual(second, third, "Unmodified builds return same result");
}


// ===========================================
//  Main Test Runner
// ===========================================

int main()
{
	std::cout << std::endl;
	std::cout << BOLD << "╔═══════════════════════════════════════════════════════════╗" << RESET << std::endl;
	std::cout << BOLD << "║     WEBSERV RESPONSE GENERATION TESTS (Step 6.1)          ║" << RESET << std::endl;
	std::cout << BOLD << "╚═══════════════════════════════════════════════════════════╝" << RESET << std::endl;

	// Run all test suites
	testStatusLine();
	testContentTypeHeader();
	testContentLengthHeader();
	testDateHeader();
	testServerHeader();
	testConnectionHeader();
	testResponseFormat();
	testDefaultErrorPages();
	testFactoryMethods();
	testMimeTypes();
	testReasonPhrases();
	testGetters();
	testCopySemantics();
	testBinaryData();
	testLazyBuilding();

	// Print summary
	std::cout << std::endl;
	std::cout << BOLD << "═══════════════════════════════════════════════════════════" << RESET << std::endl;
	std::cout << BOLD << "                    TEST SUMMARY" << RESET << std::endl;
	std::cout << BOLD << "═══════════════════════════════════════════════════════════" << RESET << std::endl;
	std::cout << GREEN << "  Passed: " << g_passed << RESET << std::endl;
	std::cout << RED   << "  Failed: " << g_failed << RESET << std::endl;
	std::cout << BOLD << "  Total:  " << (g_passed + g_failed) << RESET << std::endl;
	std::cout << BOLD << "═══════════════════════════════════════════════════════════" << RESET << std::endl;

	if (g_failed == 0)
	{
		std::cout << std::endl;
		std::cout << GREEN << BOLD << "  ✓ ALL TESTS PASSED!" << RESET << std::endl;
		std::cout << std::endl;
		return 0;
	}
	else
	{
		std::cout << std::endl;
		std::cout << RED << BOLD << "  ✗ SOME TESTS FAILED" << RESET << std::endl;
		std::cout // filepath: /home/anemet/webserv/src/test_response.cpp
/* ************************************************************************** */
/*                                                                            */
/*   test_response.cpp - Unit tests for Response Generation (Step 6.1)       */
/*                                                                            */
/* ************************************************************************** */

/*
	=================================
		TESTING WITHOUT NETWORK
	=================================

	Since the network layer isn't implemented yet, we test the Response class
	in isolation. This approach:

	1. Tests all response building logic directly
	2. Verifies HTTP format compliance
	3. Checks all status codes and headers
	4. Runs fast without socket overhead
	5. Is deterministic (no network timing issues)

	Testing Strategy:
	-----------------
	- Create Response objects using various methods
	- Build the response string
	- Parse/verify the built string contains expected components
	- Check HTTP format compliance (CRLF, headers, etc.)

	What We're Testing (Step 6.1 Requirements):
	------------------------------------------
	- Status line: "HTTP/1.1 STATUS_CODE REASON_PHRASE"
	- Standard headers: Content-Type, Content-Length, Date, Server, Connection
	- Response format: status line + headers + blank line + body
	- Default error pages for all error codes
*/

#include "Response.hpp"
#include <iostream>
#include <sstream>
#include <cstring>
#include <cstdlib>

// ===========================================
//  ANSI Color codes for pretty test output
// ===========================================
#define GREEN   "\033[32m"
#define RED     "\033[31m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define CYAN    "\033[36m"
#define RESET   "\033[0m"
#define BOLD    "\033[1m"

// Global test counters
static int g_passed = 0;
static int g_failed = 0;


// ===========================================
//  Test Helper Functions
// ===========================================

/*
	printTestHeader() - Display test section header
*/
void printTestHeader(const std::string& testName)
{
	std::cout << std::endl;
	std::cout << CYAN << BOLD << "═══════════════════════════════════════════" << RESET << std::endl;
	std::cout << CYAN << BOLD << "  " << testName << RESET << std::endl;
	std::cout << CYAN << BOLD << "═══════════════════════════════════════════" << RESET << std::endl;
}

/*
	assertTrue() - Assert a condition is true
*/
void assertTrue(bool condition, const std::string& testCase)
{
	if (condition)
	{
		std::cout << GREEN << "  ✓ PASS: " << testCase << RESET << std::endl;
		g_passed++;
	}
	else
	{
		std::cout << RED << "  ✗ FAIL: " << testCase << RESET << std::endl;
		g_failed++;
	}
}

/*
	assertEqual() - Assert two values are equal
*/
template<typename T>
void assertEqual(const T& actual, const T& expected, const std::string& testCase)
{
	if (actual == expected)
	{
		std::cout << GREEN << "  ✓ PASS: " << testCase << RESET << std::endl;
		g_passed++;
	}
	else
	{
		std::cout << RED << "  ✗ FAIL: " << testCase << RESET << std::endl;
		std::cout << RED << "    Expected: " << expected << RESET << std::endl;
		std::cout << RED << "    Actual:   " << actual << RESET << std::endl;
		g_failed++;
	}
}

/*
	assertContains() - Assert string contains substring
*/
void assertContains(const std::string& haystack, const std::string& needle,
					const std::string& testCase)
{
	if (haystack.find(needle) != std::string::npos)
	{
		std::cout << GREEN << "  ✓ PASS: " << testCase << RESET << std::endl;
		g_passed++;
	}
	else
	{
		std::cout << RED << "  ✗ FAIL: " << testCase << RESET << std::endl;
		std::cout << RED << "    String does not contain: \"" << needle << "\"" << RESET << std::endl;
		g_failed++;
	}
}

/*
	assertNotContains() - Assert string does NOT contain substring
*/
void assertNotContains(const std::string& haystack, const std::string& needle,
						const std::string& testCase)
{
	if (haystack.find(needle) == std::string::npos)
	{
		std::cout << GREEN << "  ✓ PASS: " << testCase << RESET << std::endl;
		g_passed++;
	}
	else
	{
		std::cout << RED << "  ✗ FAIL: " << testCase << RESET << std::endl;
		std::cout << RED << "    String should NOT contain: \"" << needle << "\"" << RESET << std::endl;
		g_failed++;
	}
}


// ===========================================
//  Test Cases: Status Line
// ===========================================

/*
	Test 1: Status Line Format

	HTTP responses MUST start with a status line:
	"HTTP/1.1 STATUS_CODE REASON_PHRASE\r\n"

	Examples:
	- "HTTP/1.1 200 OK\r\n"
	- "HTTP/1.1 404 Not Found\r\n"
*/
void testStatusLine()
{
	printTestHeader("STATUS LINE TESTS");

	// Test 200 OK
	{
		Response response;
		response.setStatus(200);
		std::string built = response.build();
		assertContains(built, "HTTP/1.1 200 OK\r\n", "200 OK status line");
	}

	// Test 404 Not Found
	{
		Response response;
		response.setStatus(404);
		std::string built = response.build();
		assertContains(built, "HTTP/1.1 404 Not Found\r\n", "404 Not Found status line");
	}

	// Test 500 Internal Server Error
	{
		Response response;
		response.setStatus(500);
		std::string built = response.build();
		assertContains(built, "HTTP/1.1 500 Internal Server Error\r\n", "500 status line");
	}

	// Test custom reason phrase
	{
		Response response;
		response.setStatus(418, "I'm a teapot");
		std::string built = response.build();
		assertContains(built, "HTTP/1.1 418 I'm a teapot\r\n", "Custom reason phrase");
	}
}


// ===========================================
//  Test Cases: Standard Headers
// ===========================================

/*
	Test 2: Content-Type Header

	Content-Type tells the browser how to interpret the response body.
	Without it, browsers may guess wrong (security risk!).
*/
void testContentTypeHeader()
{
	printTestHeader("CONTENT-TYPE HEADER TESTS");

	// Test HTML content type
	{
		Response response;
		response.setContentType("text/html");
		std::string built = response.build();
		assertContains(built, "Content-Type: text/html\r\n", "HTML content type");
	}

	// Test JSON content type
	{
		Response response;
		response.setContentType("application/json");
		std::string built = response.build();
		assertContains(built, "Content-Type: application/json\r\n", "JSON content type");
	}

	// Test via factory method
	{
		Response response = Response::ok("<html></html>", "text/html");
		std::string built = response.build();
		assertContains(built, "Content-Type: text/html\r\n", "Content-Type from ok() factory");
	}
}

/*
	Test 3: Content-Length Header

	Content-Length indicates the size of the body in bytes.
	Essential for HTTP/1.1 persistent connections.
*/
void testContentLengthHeader()
{
	printTestHeader("CONTENT-LENGTH HEADER TESTS");

	// Test auto-calculated Content-Length
	{
		Response response;
		response.setBody("Hello World");  // 11 bytes
		std::string built = response.build();
		assertContains(built, "Content-Length: 11\r\n", "Auto-calculated Content-Length");
	}

	// Test empty body
	{
		Response response;
		response.setBody("");
		std::string built = response.build();
		assertContains(built, "Content-Length: 0\r\n", "Content-Length for empty body");
	}

	// Test manual Content-Length
	{
		Response response;
		response.setContentLength(100);
		std::string built = response.build();
		assertContains(built, "Content-Length: 100\r\n", "Manual Content-Length");
	}

	// Test 204 No Content (should NOT have Content-Length)
	{
		Response response = Response::noContent();
		std::string built = response.build();
		assertNotContains(built, "Content-Length:", "204 No Content omits Content-Length");
	}
}

/*
	Test 4: Date Header

	Date header indicates when the response was generated.
	Format: "Date: Wed, 11 Dec 2025 12:00:00 GMT"
*/
void testDateHeader()
{
	printTestHeader("DATE HEADER TESTS");

	// Test Date header is added
	{
		Response response;
		response.addDateHeader();
		std::string built = response.build();
		assertContains(built, "Date: ", "Date header present");
		assertContains(built, " GMT\r\n", "Date header ends with GMT");
	}

	// Test addStandardHeaders includes Date
	{
		Response response;
		response.addStandardHeaders();
		std::string built = response.build();
		assertContains(built, "Date: ", "addStandardHeaders includes Date");
	}

	// Test formatHttpDate format
	{
		// January 1, 2025 00:00:00 GMT
		time_t testTime = 1735689600;
		std::string formatted = Response::formatHttpDate(testTime);
		// Should be "Wed, 01 Jan 2025 00:00:00 GMT"
		assertContains(formatted, "Jan 2025", "formatHttpDate contains month and year");
		assertContains(formatted, "GMT", "formatHttpDate contains GMT");
	}
}

/*
	Test 5: Server Header

	Server header identifies the server software.
	Example: "Server: webserv/1.0"
*/
void testServerHeader()
{
	printTestHeader("SERVER HEADER TESTS");

	// Test Server header is added
	{
		Response response;
		response.addServerHeader();
		std::string built = response.build();
		assertContains(built, "Server: webserv/1.0\r\n", "Server header present");
	}

	// Test addStandardHeaders includes Server
	{
		Response response;
		response.addStandardHeaders();
		std::string built = response.build();
		assertContains(built, "Server: webserv/1.0\r\n", "addStandardHeaders includes Server");
	}
}

/*
	Test 6: Connection Header

	Connection header controls whether the TCP connection stays open.
	- "Connection: keep-alive" - reuse connection for more requests
	- "Connection: close" - close connection after response
*/
void testConnectionHeader()
{
	printTestHeader("CONNECTION HEADER TESTS");

	// Test keep-alive (default)
	{
		Response response;
		response.setConnection(true);
		std::string built = response.build();
		assertContains(built, "Connection: keep-alive\r\n", "Connection keep-alive");
		assertTrue(response.shouldKeepAlive(), "shouldKeepAlive() returns true");
	}

	// Test close
	{
		Response response;
		response.setConnection(false);
		std::string built = response.build();
		assertContains(built, "Connection: close\r\n", "Connection close");
		assertTrue(!response.shouldKeepAlive(), "shouldKeepAlive() returns false");
	}
}


// ===========================================
//  Test Cases: Response Format
// ===========================================

/*
	Test 7: Complete Response Format

	HTTP response format:
	STATUS_LINE\r\n
	HEADER1: VALUE1\r\n
	HEADER2: VALUE2\r\n
	\r\n
	BODY
*/
void testResponseFormat()
{
	printTestHeader("RESPONSE FORMAT TESTS");

	// Test complete response structure
	{
		Response response;
		response.setStatus(200);
		response.setContentType("text/html");
		response.setBody("<html><body>Hello</body></html>");
		response.addStandardHeaders();
		std::string built = response.build();

		// Check status line comes first
		assertTrue(built.find("HTTP/1.1 200 OK\r\n") == 0, "Status line is first");

		// Check headers before body
		size_t headerEnd = built.find("\r\n\r\n");
		assertTrue(headerEnd != std::string::npos, "Headers end with blank line");

		// Check body comes after headers
		std::string body = built.substr(headerEnd + 4);
		assertContains(body, "<html><body>Hello</body></html>", "Body is after headers");
	}

	// Test CRLF line endings (not just \n)
	{
		Response response;
		response.setStatus(200);
		std::string built = response.build();
		assertContains(built, "\r\n", "Response uses CRLF line endings");
		assertNotContains(built.substr(0, 20), "\r\r", "No double CR");
	}

	// Test blank line separates headers from body
	{
		Response response;
		response.setBody("test body");
		std::string built = response.build();
		assertContains(built, "\r\n\r\ntest body", "Blank line before body");
	}
}


// ===========================================
//  Test Cases: Default Error Pages
// ===========================================

/*
	Test 8: Default Error Pages

	The server must have default error pages for all error codes.
	These are used when no custom error page is configured.
*/
void testDefaultErrorPages()
{
	printTestHeader("DEFAULT ERROR PAGES TESTS");

	// Common error codes to test
	int errorCodes[] = {400, 403, 404, 405, 413, 500, 501, 502, 504};
	int numCodes = sizeof(errorCodes) / sizeof(errorCodes[0]);

	for (int i = 0; i < numCodes; i++)
	{
		int code = errorCodes[i];
		Response response = Response::error(code);
		std::string built = response.build();

		std::ostringstream testName;
		testName << "Error " << code << " has valid status";
		assertEqual(response.getStatusCode(), code, testName.str());

		testName.str("");
		testName << "Error " << code << " has HTML body";
		assertContains(built, "<!DOCTYPE html>", testName.str());

		testName.str("");
		testName << "Error " << code << " shows error code in body";
		std::ostringstream codeStr;
		codeStr << code;
		assertContains(response.getBody(), codeStr.str(), testName.str());
	}

	// Test error page content
	{
		Response response = Response::error(404);
		std::string body = response.getBody();
		assertContains(body, "404", "404 error page shows code");
		assertContains(body, "Not Found", "404 error page shows reason");
		assertContains(body, "webserv", "Error page shows server name");
	}
}


// ===========================================
//  Test Cases: Factory Methods
// ===========================================

/*
	Test 9: Factory Methods

	Static factory methods for common response types:
	- Response::ok() for 200 OK
	- Response::error() for error responses
	- Response::redirect() for redirects
	- Response::noContent() for 204 No Content
*/
void testFactoryMethods()
{
	printTestHeader("FACTORY METHOD TESTS");

	// Test ok()
	{
		Response response = Response::ok("<p>Success</p>", "text/html");
		assertEqual(response.getStatusCode(), 200, "ok() returns 200 status");
		assertContains(response.getBody(), "Success", "ok() sets body");
		assertContains(response.build(), "Content-Type: text/html", "ok() sets content type");
	}

	// Test error()
	{
		Response response = Response::error(500);
		assertEqual(response.getStatusCode(), 500, "error() returns correct status");
		assertContains(response.build(), "Content-Type:", "error() sets content type");
		assertTrue(!response.getBody().empty(), "error() has body");
	}

	// Test redirect()
	{
		Response response = Response::redirect(301, "https://example.com/new");
		assertEqual(response.getStatusCode(), 301, "redirect() returns 301 status");
		assertContains(response.build(), "Location: https://example.com/new\r\n", 
					   "redirect() sets Location header");
		assertContains(response.getBody(), "example.com/new", "redirect() body has link");
	}

	// Test noContent()
	{
		Response response = Response::noContent();
		assertEqual(response.getStatusCode(), 204, "noContent() returns 204 status");
		assertTrue(response.getBody().empty(), "noContent() has no body");
	}
}


// ===========================================
//  Test Cases: MIME Types
// ===========================================

/*
	Test 10: MIME Type Detection

	getMimeType() should return correct Content-Type for file extensions.
*/
void testMimeTypes()
{
	printTestHeader("MIME TYPE TESTS");

	// HTML
	assertEqual(Response::getMimeType(".html"), std::string("text/html; charset=UTF-8"), 
				"MIME type for .html");
	assertEqual(Response::getMimeType(".htm"), std::string("text/html; charset=UTF-8"), 
				"MIME type for .htm");

	// CSS and JS
	assertEqual(Response::getMimeType(".css"), std::string("text/css; charset=UTF-8"), 
				"MIME type for .css");
	assertEqual(Response::getMimeType(".js"), std::string("application/javascript; charset=UTF-8"), 
				"MIME type for .js");

	// JSON
	assertEqual(Response::getMimeType(".json"), std::string("application/json; charset=UTF-8"), 
				"MIME type for .json");

	// Images
	assertEqual(Response::getMimeType(".png"), std::string("image/png"), "MIME type for .png");
	assertEqual(Response::getMimeType(".jpg"), std::string("image/jpeg"), "MIME type for .jpg");
	assertEqual(Response::getMimeType(".gif"), std::string("image/gif"), "MIME type for .gif");

	// Unknown extension
	assertEqual(Response::getMimeType(".xyz"), std::string("application/octet-stream"), 
				"MIME type for unknown extension");
}


// ===========================================
//  Test Cases: Reason Phrases
// ===========================================

/*
	Test 11: Reason Phrases

	Each status code should have a standard reason phrase.
*/
void testReasonPhrases()
{
	printTestHeader("REASON PHRASE TESTS");

	// 2xx Success
	assertEqual(Response::getReasonPhrase(200), std::string("OK"), "Reason for 200");
	assertEqual(Response::getReasonPhrase(201), std::string("Created"), "Reason for 201");
	assertEqual(Response::getReasonPhrase(204), std::string("No Content"), "Reason for 204");

	// 3xx Redirection
	assertEqual(Response::getReasonPhrase(301), std::string("Moved Permanently"), "Reason for 301");
	assertEqual(Response::getReasonPhrase(302), std::string("Found"), "Reason for 302");
	assertEqual(Response::getReasonPhrase(304), std::string("Not Modified"), "Reason for 304");

	// 4xx Client Errors
	assertEqual(Response::getReasonPhrase(400), std::string("Bad Request"), "Reason for 400");
	assertEqual(Response::getReasonPhrase(403), std::string("Forbidden"), "Reason for 403");
	assertEqual(Response::getReasonPhrase(404), std::string("Not Found"), "Reason for 404");
	assertEqual(Response::getReasonPhrase(405), std::string("Method Not Allowed"), "Reason for 405");
	assertEqual(Response::getReasonPhrase(413), std::string("Payload Too Large"), "Reason for 413");

	// 5xx Server Errors
	assertEqual(Response::getReasonPhrase(500), std::string("Internal Server Error"), "Reason for 500");
	assertEqual(Response::getReasonPhrase(502), std::string("Bad Gateway"), "Reason for 502");
	assertEqual(Response::getReasonPhrase(504), std::string("Gateway Timeout"), "Reason for 504");

	// Unknown
	assertEqual(Response::getReasonPhrase(999), std::string("Unknown"), "Reason for unknown code");
}


// ===========================================
//  Test Cases: Getters
// ===========================================

/*
	Test 12: Getter Methods
*/
void testGetters()
{
	printTestHeader("GETTER TESTS");

	Response response;
	response.setStatus(404);
	response.setHeader("X-Custom", "value123");
	response.setBody("test body content");
	response.setConnection(true);

	assertEqual(response.getStatusCode(), 404, "getStatusCode()");
	assertEqual(response.getBody(), std::string("test body content"), "getBody()");
	assertEqual(response.getHeader("X-Custom"), std::string("value123"), "getHeader() existing");
	assertEqual(response.getHeader("NonExistent"), std::string(""), "getHeader() non-existing");
	assertTrue(response.hasHeader("X-Custom"), "hasHeader() existing");
	assertTrue(!response.hasHeader("NonExistent"), "hasHeader() non-existing");
	assertTrue(response.shouldKeepAlive(), "shouldKeepAlive()");
}


// ===========================================
//  Test Cases: Copy Semantics
// ===========================================

/*
	Test 13: Copy Constructor and Assignment

	Responses are often returned by value from functions,
	so copy semantics must work correctly.
*/
void testCopySemantics()
{
	printTestHeader("COPY SEMANTICS TESTS");

	// Copy constructor
	{
		Response original;
		original.setStatus(201);
		original.setBody("original body");
		original.setHeader("X-Test", "test");

		Response copy(original);
		assertEqual(copy.getStatusCode(), 201, "Copy constructor copies status");
		assertEqual(copy.getBody(), std::string("original body"), "Copy constructor copies body");
		assertEqual(copy.getHeader("X-Test"), std::string("test"), "Copy constructor copies headers");

		// Modify original, copy should not change
		original.setStatus(500);
		assertEqual(copy.getStatusCode(), 201, "Copy is independent of original");
	}

	// Copy assignment
	{
		Response original;
		original.setStatus(202);
		original.setBody("assigned body");

		Response copy;
		copy = original;
		assertEqual(copy.getStatusCode(), 202, "Assignment copies status");
		assertEqual(copy.getBody(), std::string("assigned body"), "Assignment copies body");
	}

	// Self-assignment
	{
		Response response;
		response.setStatus(200);
		response.setBody("test");
		response = response;  // Self-assignment
		assertEqual(response.getStatusCode(), 200, "Self-assignment preserves status");
		assertEqual(response.getBody(), std::string("test"), "Self-assignment preserves body");
	}
}


// ===========================================
//  Test Cases: Binary Data
// ===========================================

/*
	Test 14: Binary Data Handling

	Response body can contain binary data (images, files).
	The Response class must handle null bytes correctly.
*/
void testBinaryData()
{
	printTestHeader("BINARY DATA TESTS");

	// Test body with null bytes
	{
		char binaryData[] = "hello\0world";  // 11 bytes including null
		Response response;
		response.setBody(binaryData, 11);

		assertEqual(response.getBody().size(), (size_t)11, "Binary body preserves size");
		assertContains(response.build(), "Content-Length: 11\r\n", "Content-Length for binary");
	}

	// Test setBody with char* and length
	{
		const char* data = "\x00\x01\x02\x03";
		Response response;
		response.setBody(data, 4);
		assertEqual(response.getBody().size(), (size_t)4, "setBody(char*, size) works");
	}
}


// ===========================================
//  Test Cases: Dirty Flag (Lazy Building)
// ===========================================

/*
	Test 15: Lazy Building / Dirty Flag

	The Response uses a "dirty" flag to avoid rebuilding
	the HTTP string unnecessarily.
*/
void testLazyBuilding()
{
	printTestHeader("LAZY BUILDING TESTS");

	Response response;
	response.setStatus(200);
	response.setBody("initial");

	// First build
	std::string first = response.build();
	assertContains(first, "initial", "First build has initial body");

	// Modify and rebuild
	response.setBody("modified");
	std::string second = response.build();
	assertContains(second, "modified", "Second build has modified body");
	assertNotContains(second, "initial", "Second build doesn't have old body");

	// Multiple builds without modification should return same result
	std::string third = response.build();
	assertEqual(second, third, "Unmodified builds return same result");
}


// ===========================================
//  Main Test Runner
// ===========================================

int main()
{
	std::cout << std::endl;
	std::cout << BOLD << "╔═══════════════════════════════════════════════════════════╗" << RESET << std::endl;
	std::cout << BOLD << "║     WEBSERV RESPONSE GENERATION TESTS (Step 6.1)          ║" << RESET << std::endl;
	std::cout << BOLD << "╚═══════════════════════════════════════════════════════════╝" << RESET << std::endl;

	// Run all test suites
	testStatusLine();
	testContentTypeHeader();
	testContentLengthHeader();
	testDateHeader();
	testServerHeader();
	testConnectionHeader();
	testResponseFormat();
	testDefaultErrorPages();
	testFactoryMethods();
	testMimeTypes();
	testReasonPhrases();
	testGetters();
	testCopySemantics();
	testBinaryData();
	testLazyBuilding();

	// Print summary
	std::cout << std::endl;
	std::cout << BOLD << "═══════════════════════════════════════════════════════════" << RESET << std::endl;
	std::cout << BOLD << "                    TEST SUMMARY" << RESET << std::endl;
	std::cout << BOLD << "═══════════════════════════════════════════════════════════" << RESET << std::endl;
	std::cout << GREEN << "  Passed: " << g_passed << RESET << std::endl;
	std::cout << RED   << "  Failed: " << g_failed << RESET << std::endl;
	std::cout << BOLD << "  Total:  " << (g_passed + g_failed) << RESET << std::endl;
	std::cout << BOLD << "═══════════════════════════════════════════════════════════" << RESET << std::endl;

	if (g_failed == 0)
	{
		std::cout << std::endl;
		std::cout << GREEN << BOLD << "  ✓ ALL TESTS PASSED!" << RESET << std::endl;
		std::cout << std::endl;
		return 0;
	}
	else
	{
		std::cout << std::endl;
		std::cout << RED << BOLD << "  ✗ SOME TESTS FAILED" << RESET << std::endl;
		std::cout 
