I'll help you implement Step 4.3: Request Body Handling. This will handle both Content-Length based bodies and chunked transfer encoding.

````cpp
// ...existing code...

bool Request::parse(const std::string& data)
{
	// Add incoming data to the buffer
	_buffer += data;

	// State machine: process based on current parsing stage
	// This allows handling requests that arrive in multiple recv() calls
	if (_state == PARSE_REQUEST_LINE)
	{
		// Look for end of line: \r\n (CRLF)
		// HTTP spec requires CRLF line endings
		size_t pos = _buffer.find("\r\n");
		if (pos == std::string::npos)
		{
			// Not enough data yet, wait for more
			// Prevent buffer overflow from malicious/broken clients
			if (_buffer.size() > 8192) // 8 kB limit for request line
			{
				_state = PARSE_ERROR;
				_errorCode = 414; // URI too long
				return true;
			}
			return false; // Need more data
		}

		// Extract request line (without \r\n)
		std::string requestLine = _buffer.substr(0, pos);

		// Remove processed data from buffer (including \r\n)
		_buffer.erase(0, pos + 2);

		// Parse the request line
		if (!parseRequestLine(requestLine))
		{
			_state = PARSE_ERROR;
			return true; // Error, but parsing is "complete"
		}

		// Move to next state: parsing headers
		_state = PARSE_HEADERS;

	} // end of PARSE_REQUEST_LINE


	// ==============================
	// 	PARSE_HEADERS State
	// ==============================
	if (_state == PARSE_HEADERS)
	{
		// Process headers line by line until we find the empty line
		while (true)
		{
			// Look for next line ending
			size_t pos = _buffer.find("\r\n");
			if (pos == std::string::npos)
			{
				// No complete line yet, need more data
				// But prevent header section from being too large
				if (_buffer.size() > 8192) // 8 kB size limit for all headers
				{
					_state = PARSE_ERROR;
					_errorCode = 431; // Request Header Fields Too Large
					return true;
				}
				return false; // Wait for more data
			}

			// Extract the line (without \r\n)
			std::string line = _buffer.substr(0, pos);

			// Remove processed line from buffer (including \r\n)
			_buffer.erase(0, pos + 2);

			// Empty line marks end of headers
			if (line.empty())
			{
				// Headers are complete!
				// Now we need to determine what comes next:

				// Check if HTTP/1.1 requires Host header
				if (_httpVersion == "HTTP/1.1")
				{
					// RFC 7230: HTTP/1.1 requests MUST include Host header
					if (getHeader("Host").empty())
					{
						_state = PARSE_ERROR;
						_errorCode = 400; // Bad Request
						return true;
					}
				}

				// Determine if request has a body
				// Body is present if:
				// 	1. Content-Length header exists OR
				// 	2. Transfer-Encoding: chunked is present

				std::string contentLength = getHeader("Content-Length");
				std::string transferEncoding = getHeader("Transfer-Encoding");

				if (!contentLength.empty())
				{
					// Content-Length body
					_contentLength = std::atol(contentLength.c_str());

					// TODO: Check against client_max_body_size from config
					// For now, use a default limit of 10MB
					if(_contentLength > 10485760) // 10 MB
					{
						_state = PARSE_ERROR;
						_errorCode = 413; // Payload Too Large
						return true;
					}

					if (_contentLength > 0)
					{
						// Request has a body, move to body parsing
						_state = PARSE_BODY;
					}
					else
					{
						// No body (Content-Length: 0)
						_state = PARSE_COMPLETE;
					}
				}
				else if (!transferEncoding.empty() &&
							transferEncoding.find("chunked") != std::string::npos)
				{
					// Chunked transfer encoding
					_state = PARSE_CHUNKED_BODY;
				}
				else
				{
					// No body indicators, request is complete
					// This is normal for GET, DELETE, etc.
					_state = PARSE_COMPLETE;
				}

				break; // Exit header parsing loop

			}	// end of empty.line - marking end-of-header

			// Parse this header line
			if (!parseHeader(line))
			{
				_state = PARSE_ERROR;
				return true; // Error in header format
			}
		}
	} // end of PARSE_HEADERS


	// =============================================
	//  PARSE_BODY State (Content-Length)
	// =============================================
	/*
		Content-Length Body Handling:

		HTTP/1.1 uses Content-Length header to specify exact body size
		Example POST request:
			POST /upload HTTP/1.1\r\n
			Host: localhost\r\n
			Content-Type: application/json\r\n
			Content-Length: 27\r\n
			\r\n
			{"name":"test","value":42}

		How it works:
			- Server knows exactly how many bytes to expect (_contentLength)
			- Read data from buffer until we have all bytes
			- Body might arrive in multiple recv() calls over network
			- Must handle partial body data gracefully

		Why this matters:
			- POST requests upload files, form data, JSON payloads
			- Server needs complete body before processing (no partial data)
			- CGI scripts expect full body on stdin
			- We can't just read indefinitely - network is unreliable

		Real-world scenario:
			Client uploads 5MB file:
			- recv() call 1: gets 64KB chunk
			- recv() call 2: gets 128KB chunk
			- recv() call 3: gets 256KB chunk
			- ... continues until all 5MB received
	*/
	if (_state == PARSE_BODY)
	{
		// Calculate how many bytes we still need
		size_t bytesNeeded = _contentLength - _bodyBytesRead;

		// How many bytes are available in buffer?
		size_t bytesAvailable = _buffer.size();

		// Take the smaller of: what we need vs what we have
		size_t bytesToRead = (bytesAvailable < bytesNeeded) ?
							  bytesAvailable : bytesNeeded;

		// Append data from buffer to body
		_body.append(_buffer, 0, bytesToRead);

		// Remove consumed data from buffer
		_buffer.erase(0, bytesToRead);

		// Update counter
		_bodyBytesRead += bytesToRead;

		// Check if we have the complete body
		if (_bodyBytesRead >= _contentLength)
		{
			// Body complete! Request is ready to process
			_state = PARSE_COMPLETE;
			return true;
		}

		// Still waiting for more body data
		return false;
	}


	// =============================================
	//  PARSE_CHUNKED_BODY State
	// =============================================
	/*
		Chunked Transfer Encoding (RFC 7230 Section 4.1)

		Used when server/client doesn't know total size upfront
		Example: dynamically generated content, live streaming

		Format:
			<chunk-size in hex>\r\n
			<chunk-data>\r\n
			<chunk-size in hex>\r\n
			<chunk-data>\r\n
			...
			0\r\n
			\r\n

		Real example:
			POST /upload HTTP/1.1\r\n
			Host: localhost\r\n
			Transfer-Encoding: chunked\r\n
			\r\n
			5\r\n
			Hello\r\n
			7\r\n
			 World!\r\n
			0\r\n
			\r\n

		Breakdown:
			"5\r\n" = next chunk is 5 bytes
			"Hello\r\n" = the 5 byte chunk + CRLF
			"7\r\n" = next chunk is 7 bytes
			" World!\r\n" = the 7 byte chunk + CRLF
			"0\r\n" = chunk size 0 = end of body
			"\r\n" = final CRLF

		Why chunked encoding exists:
			- Server generates response on-the-fly (can't pre-calculate size)
			- Client uploads large file without knowing exact size
			- Allows streaming data without buffering entire payload
			- HTTP/1.1 keep-alive requires knowing when body ends

		Important for webserv:
			- Must un-chunk before sending to CGI (CGI expects raw data)
			- Enforce size limits even for chunked data (prevent DoS)
			- Handle malformed chunks (return 400 Bad Request)
	*/
	if (_state == PARSE_CHUNKED_BODY)
	{
		if (!parseChunkedBody())
		{
			// Need more data, or parsing error occurred
			// Error code set by parseChunkedBody() if error
			return (_state == PARSE_ERROR);
		}

		// Chunked body complete
		_state = PARSE_COMPLETE;
		return true;
	}


	return (_state == PARSE_COMPLETE || _state == PARSE_ERROR);
}

// ...existing code...

/*
	parseChunkedBody() - Parse HTTP chunked transfer encoding

	Chunk format:
		<size-hex>\r\n<data>\r\n<size-hex>\r\n<data>\r\n...0\r\n\r\n

	State machine approach:
		1. Read chunk size line (hex number)
		2. Read chunk data (exactly size bytes)
		3. Read trailing CRLF after data
		4. Repeat until size = 0
		5. Read final CRLF

	Returns:
		true if chunked body is complete
		false if need more data or error occurred
*/
bool Request::parseChunkedBody()
{
	/*
		Chunked encoding state machine:
		We need to track which part of the chunk we're parsing

		States:
		- Reading chunk size line
		- Reading chunk data
		- Reading trailing CRLF after chunk data
		- Reading final CRLF after last chunk (size 0)
	*/

	while (true)
	{
		// ===================================
		//  Step 1: Parse Chunk Size Line
		// ===================================
		// Format: "<hex-size>\r\n"
		// Example: "1A\r\n" means next chunk is 26 bytes (0x1A = 26)

		// Look for the CRLF that ends the chunk size line
		size_t crlfPos = _buffer.find("\r\n");

		if (crlfPos == std::string::npos)
		{
			// Haven't received complete chunk size line yet
			// Wait for more data

			// But prevent malicious clients from sending huge chunk size
			if (_buffer.size() > 100) // Chunk size shouldn't be > 100 chars
			{
				_state = PARSE_ERROR;
				_errorCode = 400; // Bad Request
				return false;
			}

			return false; // Need more data
		}

		// Extract chunk size line (without \r\n)
		std::string chunkSizeLine = _buffer.substr(0, crlfPos);

		// Remove chunk size line from buffer (including \r\n)
		_buffer.erase(0, crlfPos + 2);

		// ===================================
		//  Step 2: Parse Hex Chunk Size
		// ===================================
		// Convert hex string to integer
		// Example: "1A" -> 26, "FF" -> 255, "0" -> 0

		// Validate hex string (only 0-9, A-F, a-f allowed)
		for (size_t i = 0; i < chunkSizeLine.length(); i++)
		{
			char c = chunkSizeLine[i];
			if (!((c >= '0' && c <= '9') ||
				  (c >= 'A' && c <= 'F') ||
				  (c >= 'a' && c <= 'f')))
			{
				// Invalid character in chunk size
				_state = PARSE_ERROR;
				_errorCode = 400; // Bad Request
				return false;
			}
		}

		// Convert hex string to number
		char* endPtr;
		size_t chunkSize = std::strtoul(chunkSizeLine.c_str(), &endPtr, 16);

		// Check for conversion errors
		if (*endPtr != '\0')
		{
			_state = PARSE_ERROR;
			_errorCode = 400; // Bad Request
			return false;
		}

		// ===================================
		//  Step 3: Handle Last Chunk (Size 0)
		// ===================================
		/*
			Chunk size 0 marks end of chunked body
			Format: "0\r\n\r\n"

			After "0\r\n", there should be one more "\r\n"
			This final CRLF marks absolute end of body
		*/
		if (chunkSize == 0)
		{
			// Last chunk! Check for final CRLF
			if (_buffer.size() < 2)
			{
				// Need more data for final CRLF
				return false;
			}

			// Verify final CRLF exists
			if (_buffer.substr(0, 2) != "\r\n")
			{
				_state = PARSE_ERROR;
				_errorCode = 400; // Bad Request
				return false;
			}

			// Remove final CRLF
			_buffer.erase(0, 2);

			// Chunked body complete!
			// _body now contains the un-chunked data ready for processing
			return true;
		}

		// ===================================
		//  Step 4: Enforce Body Size Limit
		// ===================================
		/*
			Even with chunked encoding, we must limit total body size
			Prevent DoS attacks with infinite chunks

			Example attack:
				Client sends: 1000000\r\n<1MB data>\r\n1000000\r\n<1MB data>...
				Without limit, server runs out of memory
		*/
		if (_body.size() + chunkSize > 10485760) // 10 MB limit
		{
			_state = PARSE_ERROR;
			_errorCode = 413; // Payload Too Large
			return false;
		}

		// ===================================
		//  Step 5: Read Chunk Data
		// ===================================
		// We need: chunkSize bytes + "\r\n" (2 bytes)
		size_t totalNeeded = chunkSize + 2;

		if (_buffer.size() < totalNeeded)
		{
			// Don't have complete chunk yet, need more data
			// This is normal - chunk might arrive over multiple recv() calls
			return false;
		}

		// Extract chunk data (without trailing \r\n)
		std::string chunkData = _buffer.substr(0, chunkSize);

		// Verify trailing CRLF after chunk data
		if (_buffer.substr(chunkSize, 2) != "\r\n")
		{
			_state = PARSE_ERROR;
			_errorCode = 400; // Bad Request - malformed chunk
			return false;
		}

		// Remove chunk data + trailing CRLF from buffer
		_buffer.erase(0, totalNeeded);

		// ===================================
		//  Step 6: Append Chunk to Body
		// ===================================
		/*
			Un-chunking process:
			We remove the chunk framing (size + CRLF) and just keep raw data

			Input chunks:
				5\r\nHello\r\n7\r\n World!\r\n0\r\n\r\n

			Output body:
				"Hello World!"

			This is what the application/CGI expects - pure data, no framing
		*/
		_body.append(chunkData);

		// Loop continues to parse next chunk
		// Will return false if buffer empty (need more data)
		// Will return true when we hit the "0\r\n\r\n" final chunk
	}
}

// ...existing code...
````

Now let's add a member variable to track chunked parsing state. Update the header file:

````cpp
// ...existing code...

private:
    std::string _method;
    std::string _uri;
    std::string _path;
    std::string _queryString;
    std::string _httpVersion;
    std::string _body;
    std::map<std::string, std::string> _headers;

    ParseState _state;
    int _errorCode;
    std::string _buffer;
    size_t _contentLength;
    size_t _bodyBytesRead;

    // Note: For chunked encoding, we don't need extra state tracking
    // The parseChunkedBody() function handles everything in the buffer

    bool parseRequestLine(const std::string& line);
    bool parseHeader(const std::string& line);
    bool parseChunkedBody();
};

#endif
````

Now let's create comprehensive tests for Step 4.3:

````cpp
/* ************************************************************************** */
/*   test_request_step4_3.cpp - Test for HTTP Body Parsing                  */
/* ************************************************************************** */

#include "Request.hpp"
#include <iostream>
#include <string>
#include <sstream>

// Color codes
#define GREEN "\033[32m"
#define RED "\033[31m"
#define YELLOW "\033[33m"
#define BLUE "\033[34m"
#define RESET "\033[0m"

int g_passed = 0;
int g_failed = 0;

void testRequest(const std::string& testName,
				 const std::string& requestData,
				 bool shouldSucceed,
				 const std::string& expectedBody = "",
				 int expectedError = 0)
{
	std::cout << "\n" << YELLOW << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << RESET << std::endl;
	std::cout << BLUE << "Test: " << testName << RESET << std::endl;

	Request req;
	bool complete = req.parse(requestData);

	bool testPassed = false;

	if (shouldSucceed)
	{
		if (complete && !req.hasError())
		{
			if (req.getBody() == expectedBody)
			{
				testPassed = true;
				std::cout << GREEN << "âœ“ PASS" << RESET << std::endl;
				std::cout << "  Method:       " << req.getMethod() << std::endl;
				std::cout << "  URI:          " << req.getUri() << std::endl;
				std::cout << "  Body Length:  " << req.getBody().length() << " bytes" << std::endl;
				if (!expectedBody.empty() && expectedBody.length() < 100)
				{
					std::cout << "  Body Content: \"" << req.getBody() << "\"" << std::endl;
				}
			}
			else
			{
				std::cout << RED << "âœ— FAIL - Body mismatch" << RESET << std::endl;
				std::cout << "  Expected: \"" << expectedBody << "\"" << std::endl;
				std::cout << "  Got:      \"" << req.getBody() << "\"" << std::endl;
			}
		}
		else if (!complete)
		{
			std::cout << RED << "âœ— FAIL - Parsing incomplete" << RESET << std::endl;
			std::cout << "  State: " << req.getState() << std::endl;
		}
		else
		{
			std::cout << RED << "âœ— FAIL - Got error " << req.getErrorCode() << RESET << std::endl;
		}
	}
	else
	{
		if (req.hasError() && req.getErrorCode() == expectedError)
		{
			testPassed = true;
			std::cout << GREEN << "âœ“ PASS - Correctly rejected with error "
					 << expectedError << RESET << std::endl;
		}
		else if (!req.hasError())
		{
			std::cout << RED << "âœ— FAIL - Should have failed but succeeded" << RESET << std::endl;
		}
		else
		{
			std::cout << RED << "âœ— FAIL - Expected error " << expectedError
					 << ", got " << req.getErrorCode() << RESET << std::endl;
		}
	}

	if (testPassed)
		g_passed++;
	else
		g_failed++;
}

void testIncrementalBody()
{
	std::cout << "\n" << YELLOW << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << RESET << std::endl;
	std::cout << BLUE << "Test: Incremental Body Parsing (Multiple recv() calls)" << RESET << std::endl;

	Request req;

	// Send headers first
	std::string chunk1 = "POST /upload HTTP/1.1\r\n"
						 "Host: localhost\r\n"
						 "Content-Length: 26\r\n"
						 "\r\n";

	bool complete = req.parse(chunk1);
	if (complete)
	{
		std::cout << RED << "  âœ— Should not complete with only headers" << RESET << std::endl;
		g_failed++;
		return;
	}

	// Send body in chunks
	std::string chunk2 = "Hello, ";
	complete = req.parse(chunk2);
	if (complete)
	{
		std::cout << RED << "  âœ— Should not complete with partial body" << RESET << std::endl;
		g_failed++;
		return;
	}

	std::string chunk3 = "this is ";
	complete = req.parse(chunk3);
	if (complete)
	{
		std::cout << RED << "  âœ— Should not complete with partial body" << RESET << std::endl;
		g_failed++;
		return;
	}

	std::string chunk4 = "a test body!";
	complete = req.parse(chunk4);

	if (complete && !req.hasError() && req.getBody() == "Hello, this is a test body!")
	{
		std::cout << GREEN << "âœ“ PASS - Incremental parsing works" << RESET << std::endl;
		std::cout << "  Final body: \"" << req.getBody() << "\"" << std::endl;
		g_passed++;
	}
	else
	{
		std::cout << RED << "âœ— FAIL - Incremental parsing failed" << RESET << std::endl;
		std::cout << "  Complete: " << complete << std::endl;
		std::cout << "  Body: \"" << req.getBody() << "\"" << std::endl;
		g_failed++;
	}
}

int main()
{
	std::cout << "\n" << BLUE;
	std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
	std::cout << "â•‘                                                           â•‘\n";
	std::cout << "â•‘   WEBSERV - Step 4.3: Request Body Handling Tests        â•‘\n";
	std::cout << "â•‘                                                           â•‘\n";
	std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
	std::cout << RESET << std::endl;

	// ========================================================================
	// SECTION 1: Content-Length Body Parsing
	// ========================================================================

	std::cout << "\n" << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;
	std::cout << YELLOW << "  SECTION 1: Content-Length Body Parsing" << RESET << std::endl;
	std::cout << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;

	testRequest("Simple POST with body",
				"POST /upload HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Content-Length: 13\r\n"
				"\r\n"
				"Hello, World!",
				true, "Hello, World!");

	testRequest("POST with JSON body",
				"POST /api/data HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Content-Type: application/json\r\n"
				"Content-Length: 27\r\n"
				"\r\n"
				"{\"name\":\"test\",\"value\":42}",
				true, "{\"name\":\"test\",\"value\":42}");

	testRequest("POST with empty body (Content-Length: 0)",
				"POST /api/ping HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Content-Length: 0\r\n"
				"\r\n",
				true, "");

	testRequest("POST with multiline body",
				"POST /form HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Content-Length: 35\r\n"
				"\r\n"
				"name=John\nage=30\nemail=j@test.com",
				true, "name=John\nage=30\nemail=j@test.com");

	// ========================================================================
	// SECTION 2: Chunked Transfer Encoding
	// ========================================================================

	std::cout << "\n" << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;
	std::cout << YELLOW << "  SECTION 2: Chunked Transfer Encoding" << RESET << std::endl;
	std::cout << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;

	testRequest("Simple chunked body",
				"POST /upload HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Transfer-Encoding: chunked\r\n"
				"\r\n"
				"5\r\n"
				"Hello\r\n"
				"0\r\n"
				"\r\n",
				true, "Hello");

	testRequest("Multiple chunks",
				"POST /upload HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Transfer-Encoding: chunked\r\n"
				"\r\n"
				"5\r\n"
				"Hello\r\n"
				"7\r\n"
				" World!\r\n"
				"0\r\n"
				"\r\n",
				true, "Hello World!");

	testRequest("Chunked with hex uppercase",
				"POST /upload HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Transfer-Encoding: chunked\r\n"
				"\r\n"
				"A\r\n"
				"0123456789\r\n"
				"0\r\n"
				"\r\n",
				true, "0123456789");

	testRequest("Single chunk with data",
				"POST /upload HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Transfer-Encoding: chunked\r\n"
				"\r\n"
				"D\r\n"
				"Test message!\r\n"
				"0\r\n"
				"\r\n",
				true, "Test message!");

	// ========================================================================
	// SECTION 3: Error Cases
	// ========================================================================

	std::cout << "\n" << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;
	std::cout << YELLOW << "  SECTION 3: Error Handling" << RESET << std::endl;
	std::cout << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;

	testRequest("Body exceeds limit (413)",
				"POST /upload HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Content-Length: 99999999\r\n"
				"\r\n",
				false, "", 413);

	testRequest("Invalid chunk size (not hex)",
				"POST /upload HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Transfer-Encoding: chunked\r\n"
				"\r\n"
				"XYZ\r\n"
				"Hello\r\n"
				"0\r\n"
				"\r\n",
				false, "", 400);

	testRequest("Chunked missing final CRLF",
				"POST /upload HTTP/1.1\r\n"
				"Host: localhost\r\n"
				"Transfer-Encoding: chunked\r\n"
				"\r\n"
				"5\r\n"
				"Hello\r\n"
				"0\r\n",
				false, "", 400);

	// ========================================================================
	// SECTION 4: Special Tests
	// ========================================================================

	std::cout << "\n" << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;
	std::cout << YELLOW << "  SECTION 4: Special Cases" << RESET << std::endl;
	std::cout << YELLOW << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;

	testIncrementalBody();

	// ========================================================================
	// SUMMARY
	// ========================================================================

	std::cout << "\n" << BLUE;
	std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
	std::cout << "â•‘                      TEST SUMMARY                         â•‘\n";
	std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
	std::cout << RESET << std::endl;

	int total = g_passed + g_failed;
	std::cout << "  Total tests:  " << total << std::endl;
	std::cout << GREEN << "  Passed:       " << g_passed << RESET << std::endl;
	std::cout << RED << "  Failed:       " << g_failed << RESET << std::endl;

	if (g_failed == 0)
	{
		std::cout << "\n" << GREEN << "ðŸŽ‰ ALL TESTS PASSED! Step 4.3 is complete! ðŸŽ‰" << RESET << "\n" << std::endl;
		return 0;
	}
	else
	{
		std::cout << "\n" << RED << "âŒ Some tests failed. Review the output above." << RESET << "\n" << std::endl;
		return 1;
	}
}
````

The implementation includes:

1. **Content-Length Body Parsing**: Reads exact number of bytes specified in header
2. **Chunked Transfer Encoding**: Parses hex chunk sizes, un-chunks data, handles final chunk
3. **Incremental Parsing**: Handles body arriving in multiple `recv()` calls
4. **Size Limits**: Enforces 10MB limit for both Content-Length and chunked bodies
5. **Error Handling**: Validates chunk format, detects malformed chunks, prevents buffer overflows
6. **Complete Un-chunking**: Removes all chunk framing for CGI/application consumption

Compile and test:
```bash
make
./webserv
```

Your request parser is now complete and ready for Phase 5 (routing and responses)!
