# Step 5.1: Router Implementation

The Router is responsible for matching incoming HTTP requests to the appropriate location block in our configuration and determining how to handle each request.

## Router.cpp Implementation

````cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Router.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anemet <anemet@student.42luxembourg.lu>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/10 18:00:00 by anemet            #+#    #+#             */
/*   Updated: 2025/12/10 18:00:00 by anemet           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Router.hpp"
#include "Config.hpp"
#include <sys/stat.h>
#include <dirent.h>
#include <fstream>
#include <sstream>
#include <ctime>
#include <algorithm>
#include <unistd.h>
#include <fcntl.h>

/*
    ============================================================================
    ROUTER OVERVIEW - What is Routing?
    ============================================================================

    Routing is the process of determining how to handle an HTTP request based on:
    1. The request URI (path)
    2. The HTTP method (GET, POST, DELETE)
    3. The server configuration (location blocks)

    Example config:
        server {
            listen 8080;

            location / {
                root /var/www;
                index index.html;
                allow_methods GET;
            }

            location /upload {
                root /var/www;
                allow_methods POST DELETE;
                upload_dir /var/www/uploads;
            }

            location /api {
                root /var/www;
                allow_methods GET POST;
            }
        }

    When request "GET /upload/file.txt" arrives:
    1. Find server listening on the request's port (8080)
    2. Match URI "/upload/file.txt" to location blocks
    3. "/upload" matches better than "/" (more specific)
    4. Check if GET is allowed for /upload -> NO! Only POST DELETE
    5. Return 405 Method Not Allowed

    When request "GET /index.html" arrives:
    1. Match URI "/" (no more specific match)
    2. GET is allowed for /
    3. Resolve path: root + URI = /var/www/index.html
    4. Serve the file

    ============================================================================
*/

// ==============================================
//       Constructors & Destructors
// ==============================================

/*
    Default Constructor

    Creates a Router with no configuration.
    setConfig() must be called before routing requests.
    This pattern allows the Router to be created early and configured later.
*/
Router::Router() : _config(NULL)
{
}

/*
    Parameterized Constructor

    Creates a Router with a reference to the server configuration.
    The Router does NOT own the Config - it just references it.
    The Config must remain valid for the Router's lifetime.
*/
Router::Router(const Config& config) : _config(&config)
{
}

/*
    Destructor

    Nothing to clean up - we don't own the Config pointer.
*/
Router::~Router()
{
}

/*
    Copy Constructor
*/
Router::Router(const Router& other) : _config(other._config)
{
}

/*
    Copy Assignment Operator
*/
Router& Router::operator=(const Router& other)
{
    if (this != &other)
    {
        _config = other._config;
    }
    return *this;
}

// ==============================================
//       Configuration
// ==============================================

/*
    setConfig() - Set or update the configuration reference

    Why this exists:
    - Server might be created before config is fully parsed
    - Config might be reloaded at runtime (SIGHUP)
    - Allows dependency injection for testing
*/
void Router::setConfig(const Config& config)
{
    _config = &config;
}

// ==============================================
//       Main Routing Logic
// ==============================================

/*
    route() - The main routing function

    This is the heart of the Router. It takes an HTTP request and determines
    how to handle it based on the server configuration.

    Routing Algorithm:
    1. Find the server block that matches the request's port
    2. Find the location block that best matches the request URI
    3. Check if the HTTP method is allowed for this location
    4. Handle redirections if configured
    5. Dispatch to appropriate handler (GET, POST, DELETE, CGI)

    Parameters:
        request    - The parsed HTTP request
        serverPort - The port the request came in on (needed to find correct server block)

    Returns:
        Response object ready to be sent to the client

    Real-world example:
        Request: GET /images/photo.jpg HTTP/1.1
        Port: 8080

        1. Find server on port 8080
        2. Match /images/photo.jpg to locations:
           - "/" matches (prefix)
           - "/images" matches better (longer prefix)
        3. Use /images location config
        4. Check: is GET allowed? Yes
        5. Resolve path: root + /photo.jpg
        6. Serve the file
*/
Response Router::route(const Request& request, int serverPort)
{
    // ========================================
    // Step 1: Validate configuration
    // ========================================
    if (!_config)
    {
        // No config = internal server error
        // This should never happen in production
        return errorResponse(500);
    }

    // ========================================
    // Step 2: Find matching server block
    // ========================================
    /*
        A webserver can host multiple "virtual servers" on different ports.
        Example:
            - Port 8080: Main website
            - Port 8081: Admin panel
            - Port 8082: API server

        We need to find which server block handles this port.
    */
    const ServerConfig* server = findServer(serverPort);
    if (!server)
    {
        // No server configured for this port
        // This shouldn't happen if the connection was accepted
        return errorResponse(500);
    }

    // ========================================
    // Step 3: Find matching location block
    // ========================================
    /*
        Location matching in webservers follows "longest prefix match":

        Locations: /, /api, /api/v1, /images

        Request: /api/v1/users
        - "/" matches (prefix of /api/v1/users) âœ“
        - "/api" matches (prefix of /api/v1/users) âœ“
        - "/api/v1" matches (prefix of /api/v1/users) âœ“ BEST!
        - "/images" doesn't match âœ—

        We pick "/api/v1" as it's the longest (most specific) match.
    */
    std::string requestPath = request.getPath();
    const LocationConfig* location = findLocation(*server, requestPath);

    if (!location)
    {
        // No location matches - use server's default settings
        // or return 404 if no default location
        return errorResponse(404, server);
    }

    // ========================================
    // Step 4: Check for redirections
    // ========================================
    /*
        Redirections tell the client to go elsewhere.
        Example config:
            location /old-page {
                return 301 /new-page;
            }

        Response:
            HTTP/1.1 301 Moved Permanently
            Location: /new-page

        301 = Permanent redirect (browsers cache this)
        302 = Temporary redirect (browsers don't cache)
    */
    if (!location->redirect.empty())
    {
        return Response::redirect(location->redirectCode, location->redirect);
    }

    // ========================================
    // Step 5: Check HTTP method allowed
    // ========================================
    /*
        Each location can restrict which HTTP methods are allowed.
        Example:
            location /upload {
                allow_methods POST;  # Only POST allowed
            }

        If client sends GET to /upload -> 405 Method Not Allowed

        Why this matters:
        - Security: prevent unwanted operations
        - API design: RESTful endpoints
        - Protection: read-only areas shouldn't accept DELETE
    */
    std::string method = request.getMethod();
    if (!isMethodAllowed(method, *location))
    {
        return errorResponse(405, server);
    }

    // ========================================
    // Step 6: Check for CGI
    // ========================================
    /*
        CGI (Common Gateway Interface) runs external programs to generate
        dynamic content (PHP, Python, etc.)

        Detection based on file extension:
        - /script.php -> run PHP interpreter
        - /script.py -> run Python interpreter

        This is configured per-location with cgi_extension and cgi_path
    */
    std::string resolvedPath = resolvePath(requestPath, *location);
    if (isCgiRequest(resolvedPath, *location))
    {
        return handleCgi(request, resolvedPath, *location);
    }

    // ========================================
    // Step 7: Dispatch to method handler
    // ========================================
    /*
        Each HTTP method has different semantics:
        - GET: Retrieve a resource (read-only)
        - POST: Submit data (create, upload)
        - DELETE: Remove a resource

        Each needs different handling logic.
    */
    if (method == "GET" || method == "HEAD")
    {
        return handleGet(request, *location);
    }
    else if (method == "POST")
    {
        return handlePost(request, *location);
    }
    else if (method == "DELETE")
    {
        return handleDelete(request, *location);
    }

    // Method not implemented (shouldn't reach here if Request validates methods)
    return errorResponse(501, server);
}

// ==============================================
//       Server & Location Finding
// ==============================================

/*
    findServer() - Find the server block for a given port

    Webservers can have multiple server blocks, each handling different ports
    or hostnames (virtual hosting).

    For simplicity, we match by port only.
    Full virtual hosting would also check the Host header.

    Parameters:
        port - The port number the request came in on

    Returns:
        Pointer to matching ServerConfig, or NULL if not found
*/
const ServerConfig* Router::findServer(int port) const
{
    const std::vector<ServerConfig>& servers = _config->getServers();

    for (size_t i = 0; i < servers.size(); ++i)
    {
        if (servers[i].port == port)
        {
            return &servers[i];
        }
    }

    // No exact match - return first server as default
    // This mimics NGINX's default_server behavior
    if (!servers.empty())
    {
        return &servers[0];
    }

    return NULL;
}

/*
    findLocation() - Find the best matching location for a URI path

    Implements "longest prefix match" algorithm:

    Example:
        Locations: "/", "/api", "/api/users"
        Request path: "/api/users/123"

        Matches:
        - "/" is prefix of "/api/users/123" (length 1)
        - "/api" is prefix of "/api/users/123" (length 4)
        - "/api/users" is prefix of "/api/users/123" (length 10) <- WINNER

    Parameters:
        server - The server block to search within
        path   - The request URI path to match

    Returns:
        Pointer to best matching LocationConfig, or NULL if none match
*/
const LocationConfig* Router::findLocation(const ServerConfig& server,
                                           const std::string& path) const
{
    const LocationConfig* bestMatch = NULL;
    size_t bestMatchLength = 0;

    const std::vector<LocationConfig>& locations = server.locations;

    for (size_t i = 0; i < locations.size(); ++i)
    {
        const std::string& locationPath = locations[i].path;

        // Check if location path is a prefix of the request path
        // Location "/api" should match "/api", "/api/", "/api/users"
        if (path.compare(0, locationPath.length(), locationPath) == 0)
        {
            // Additional check: ensure we match at path boundary
            // "/api" should NOT match "/apiary"
            // It should match: "/api", "/api/", "/api/anything"
            if (path.length() == locationPath.length() ||  // Exact match
                locationPath == "/" ||                      // Root always matches
                path[locationPath.length()] == '/')         // Followed by /
            {
                // This location matches - is it better than current best?
                if (locationPath.length() > bestMatchLength)
                {
                    bestMatch = &locations[i];
                    bestMatchLength = locationPath.length();
                }
            }
        }
    }

    return bestMatch;
}

// ==============================================
//       Path Resolution & Validation
// ==============================================

/*
    resolvePath() - Convert URI to filesystem path

    This is a critical security function!

    The URI from the request must be combined with the location's root
    to find the actual file on disk.

    Example:
        Location config:
            location /images {
                root /var/www;
            }

        Request: GET /images/photo.jpg
        Resolved: /var/www/images/photo.jpg

    SECURITY: Must prevent directory traversal attacks!
        Request: GET /images/../../../etc/passwd
        BAD: /var/www/images/../../../etc/passwd = /etc/passwd
        GOOD: Detect ".." and reject or sanitize

    Parameters:
        uri      - The request URI path
        location - The matching location configuration

    Returns:
        Absolute filesystem path to the requested resource
*/
std::string Router::resolvePath(const std::string& uri, const LocationConfig& location)
{
    std::string root = location.root;

    // Ensure root doesn't end with /
    if (!root.empty() && root[root.length() - 1] == '/')
    {
        root = root.substr(0, root.length() - 1);
    }

    // For the URI, we need to handle the location path prefix
    // If location is "/images" and URI is "/images/photo.jpg"
    // We want: root + "/images/photo.jpg" or root + "/photo.jpg"
    // depending on how the root is configured

    std::string path = uri;

    // Security: Sanitize path to prevent directory traversal
    // Remove any ".." components
    std::string sanitized;
    std::istringstream iss(path);
    std::string segment;
    std::vector<std::string> segments;

    // Split path by '/' and process
    while (std::getline(iss, segment, '/'))
    {
        if (segment == "..")
        {
            // Go up one directory - but don't go above root!
            if (!segments.empty())
            {
                segments.pop_back();
            }
            // If segments is empty, we'd be going above root - ignore
        }
        else if (segment == "." || segment.empty())
        {
            // Current directory or empty segment - skip
            continue;
        }
        else
        {
            segments.push_back(segment);
        }
    }

    // Rebuild sanitized path
    sanitized = "";
    for (size_t i = 0; i < segments.size(); ++i)
    {
        sanitized += "/" + segments[i];
    }

    if (sanitized.empty())
    {
        sanitized = "/";
    }

    // Combine root with sanitized path
    std::string fullPath = root + sanitized;

    return fullPath;
}

/*
    isMethodAllowed() - Check if HTTP method is permitted for this location

    Each location block can specify which methods are allowed:
        location /readonly {
            allow_methods GET;
        }
        location /api {
            allow_methods GET POST PUT DELETE;
        }

    Parameters:
        method   - The HTTP method (GET, POST, DELETE, etc.)
        location - The location configuration to check

    Returns:
        true if method is allowed, false otherwise
*/
bool Router::isMethodAllowed(const std::string& method, const LocationConfig& location)
{
    // If no methods specified, allow all (or just GET by default)
    if (location.allowedMethods.empty())
    {
        // Default behavior: allow GET only
        return (method == "GET" || method == "HEAD");
    }

    // Check if method is in the allowed list
    for (size_t i = 0; i < location.allowedMethods.size(); ++i)
    {
        if (location.allowedMethods[i] == method)
        {
            return true;
        }
        // HEAD is allowed if GET is allowed (HEAD = GET without body)
        if (method == "HEAD" && location.allowedMethods[i] == "GET")
        {
            return true;
        }
    }

    return false;
}

/*
    isCgiRequest() - Determine if request should be handled by CGI

    CGI requests are identified by file extension:
        - .php -> PHP CGI
        - .py  -> Python CGI
        - .pl  -> Perl CGI

    The location must have CGI configured for this extension.

    Parameters:
        path     - The resolved filesystem path
        location - The location configuration

    Returns:
        true if this should be handled as CGI, false otherwise
*/
bool Router::isCgiRequest(const std::string& path, const LocationConfig& location)
{
    // Check if CGI is configured for this location
    if (location.cgiExtension.empty() || location.cgiPath.empty())
    {
        return false;
    }

    // Check if path ends with the CGI extension
    const std::string& ext = location.cgiExtension;
    if (path.length() >= ext.length())
    {
        return (path.compare(path.length() - ext.length(), ext.length(), ext) == 0);
    }

    return false;
}

// ==============================================
//       HTTP Method Handlers
// ==============================================

/*
    handleGet() - Handle GET and HEAD requests

    GET retrieves a resource (file, directory listing, etc.)
    HEAD is identical to GET but returns only headers (no body)

    Process:
    1. Resolve the filesystem path
    2. Check if path exists
    3. If directory: serve index file or directory listing
    4. If file: serve the file content

    Parameters:
        request  - The HTTP request
        location - The matching location configuration

    Returns:
        Response with file content or appropriate error
*/
Response Router::handleGet(const Request& request, const LocationConfig& location)
{
    std::string path = resolvePath(request.getPath(), location);

    // Use stat() to check if path exists and get info
    struct stat pathStat;
    if (stat(path.c_str(), &pathStat) != 0)
    {
        // Path doesn't exist
        return errorResponse(404);
    }

    // Check if it's a directory
    if (S_ISDIR(pathStat.st_mode))
    {
        return serveDirectory(path, location);
    }

    // It's a file - serve it
    return serveFile(path);
}

/*
    handlePost() - Handle POST requests

    POST is used for:
    - Form submissions
    - File uploads
    - Creating new resources

    For file uploads, we need to:
    1. Parse the request body (multipart/form-data or raw)
    2. Save uploaded files to the upload directory
    3. Return success/failure response

    Parameters:
        request  - The HTTP request (contains body data)
        location - The matching location configuration

    Returns:
        Response indicating success (201 Created) or error
*/
Response Router::handlePost(const Request& request, const LocationConfig& location)
{
    // Check if upload directory is configured
    if (location.uploadDir.empty())
    {
        // No upload directory configured - reject
        // Could also handle as form submission
        return errorResponse(403);
    }

    // For now, implement simple file upload
    // Full implementation would parse multipart/form-data

    // Get Content-Type to determine how to handle body
    std::string contentType = request.getHeader("Content-Type");

    // Simple implementation: save body as raw file
    // Generate filename from timestamp
    std::ostringstream filename;
    filename << location.uploadDir << "/upload_" << time(NULL);

    // Try to create the file
    std::ofstream outFile(filename.str().c_str(), std::ios::binary);
    if (!outFile)
    {
        return errorResponse(500);  // Couldn't create file
    }

    outFile << request.getBody();
    outFile.close();

    // Success - return 201 Created
    Response response;
    response.setStatus(201, "Created");
    response.setHeader("Location", filename.str());
    response.setContentType("text/plain");
    response.setBody("File uploaded successfully\n");

    return response;
}

/*
    handleDelete() - Handle DELETE requests

    DELETE removes a resource from the server.

    Security considerations:
    - Only allow deletion within allowed directories
    - Don't allow deleting directories (or require special handling)
    - Log deletions for audit trail

    Parameters:
        request  - The HTTP request
        location - The matching location configuration

    Returns:
        204 No Content on success, or error response
*/
Response Router::handleDelete(const Request& request, const LocationConfig& location)
{
    std::string path = resolvePath(request.getPath(), location);

    // Check if file exists
    struct stat pathStat;
    if (stat(path.c_str(), &pathStat) != 0)
    {
        return errorResponse(404);  // Not Found
    }

    // Don't allow deleting directories
    if (S_ISDIR(pathStat.st_mode))
    {
        return errorResponse(409);  // Conflict
    }

    // Attempt to delete the file
    if (unlink(path.c_str()) != 0)
    {
        return errorResponse(403);  // Forbidden (permission denied)
    }

    // Success - return 204 No Content
    Response response;
    response.setStatus(204, "No Content");
    return response;
}

// ==============================================
//       File Serving
// ==============================================

/*
    serveFile() - Read and return a file's contents

    Process:
    1. Open the file
    2. Read contents into memory
    3. Determine Content-Type from extension
    4. Build response with appropriate headers

    Parameters:
        filepath - Absolute path to the file

    Returns:
        Response with file contents and appropriate headers
*/
Response Router::serveFile(const std::string& filepath)
{
    // Open file for reading in binary mode
    std::ifstream file(filepath.c_str(), std::ios::binary);
    if (!file)
    {
        return errorResponse(404);
    }

    // Read entire file into string
    std::ostringstream contents;
    contents << file.rdbuf();
    file.close();

    // Determine Content-Type from file extension
    std::string extension;
    size_t dotPos = filepath.rfind('.');
    if (dotPos != std::string::npos)
    {
        extension = filepath.substr(dotPos);
    }

    std::string contentType = Response::getMimeType(extension);

    // Build response
    Response response;
    response.setStatus(200, "OK");
    response.setContentType(contentType);
    response.setBody(contents.str());

    return response;
}

/*
    serveDirectory() - Handle directory requests

    When a directory is requested, we can:
    1. Serve an index file (index.html) if it exists
    2. Generate a directory listing if enabled
    3. Return 403 Forbidden if directory listing is disabled

    Parameters:
        dirpath  - Absolute path to the directory
        location - Location configuration (has index and autoindex settings)

    Returns:
        Response with index file, directory listing, or error
*/
Response Router::serveDirectory(const std::string& dirpath, const LocationConfig& location)
{
    // First, try to serve index file
    if (!location.index.empty())
    {
        std::string indexPath = dirpath;
        if (indexPath[indexPath.length() - 1] != '/')
        {
            indexPath += "/";
        }
        indexPath += location.index;

        struct stat indexStat;
        if (stat(indexPath.c_str(), &indexStat) == 0 && S_ISREG(indexStat.st_mode))
        {
            return serveFile(indexPath);
        }
    }

    // No index file - check if directory listing is enabled
    if (!location.autoindex)
    {
        return errorResponse(403);  // Forbidden - no directory listing
    }

    // Generate directory listing
    DIR* dir = opendir(dirpath.c_str());
    if (!dir)
    {
        return errorResponse(500);
    }

    // Build HTML directory listing
    std::ostringstream html;
    html << "<!DOCTYPE html>\n";
    html << "<html>\n<head>\n";
    html << "<title>Index of " << dirpath << "</title>\n";
    html << "<style>\n";
    html << "body { font-family: monospace; }\n";
    html << "a { text-decoration: none; }\n";
    html << "a:hover { text-decoration: underline; }\n";
    html << "</style>\n";
    html << "</head>\n<body>\n";
    html << "<h1>Index of " << dirpath << "</h1>\n";
    html << "<hr>\n<pre>\n";

    // Add parent directory link
    html << "<a href=\"../\">..</a>\n";

    // List directory contents
    struct dirent* entry;
    while ((entry = readdir(dir)) != NULL)
    {
        std::string name = entry->d_name;

        // Skip . and ..
        if (name == "." || name == "..")
        {
            continue;
        }

        // Check if it's a directory
        std::string fullPath = dirpath + "/" + name;
        struct stat entryStat;
        if (stat(fullPath.c_str(), &entryStat) == 0 && S_ISDIR(entryStat.st_mode))
        {
            name += "/";
        }

        html << "<a href=\"" << name << "\">" << name << "</a>\n";
    }

    closedir(dir);

    html << "</pre>\n<hr>\n";
    html << "</body>\n</html>\n";

    Response response;
    response.setStatus(200, "OK");
    response.setContentType("text/html");
    response.setBody(html.str());

    return response;
}

// ==============================================
//       CGI Handling (Stub)
// ==============================================

/*
    handleCgi() - Execute CGI script and return response

    This is a stub for now - full implementation in Phase 8.

    CGI execution involves:
    1. fork() to create child process
    2. Set up pipes for stdin/stdout
    3. Set environment variables
    4. execve() the CGI interpreter
    5. Read output and parse headers

    Parameters:
        request    - The HTTP request
        scriptPath - Path to the CGI script
        location   - Location configuration

    Returns:
        Response from CGI script or error
*/
Response Router::handleCgi(const Request& request, const std::string& scriptPath,
                           const LocationConfig& location)
{
    // TODO: Implement in Phase 8 (CGI)
    // For now, return 501 Not Implemented
    (void)request;
    (void)scriptPath;
    (void)location;

    return errorResponse(501);
}

// ==============================================
//       Error Response Generation
// ==============================================

/*
    errorResponse() - Generate an HTTP error response

    Creates an error response with:
    - Appropriate status code and reason phrase
    - Custom error page (if configured) or default page
    - Required headers

    Parameters:
        code   - HTTP error code (400, 404, 500, etc.)
        server - Optional server config for custom error pages

    Returns:
        Error response ready to send
*/
Response Router::errorResponse(int code, const ServerConfig* server)
{
    // Check for custom error page
    if (server)
    {
        std::map<int, std::string>::const_iterator it = server->errorPages.find(code);
        if (it != server->errorPages.end())
        {
            // Custom error page configured
            std::string errorPagePath = it->second;

            // Try to serve the custom error page
            std::ifstream file(errorPagePath.c_str());
            if (file)
            {
                std::ostringstream contents;
                contents << file.rdbuf();
                file.close();

                Response response;
                response.setStatus(code);
                response.setContentType("text/html");
                response.setBody(contents.str());
                return response;
            }
        }
    }

    // Default error page
    return Response::error(code);
}
````

## Config.hpp - Required Structures

You'll need these structures in your Config.hpp for the Router to work:

````cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Config.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anemet <anemet@student.42luxembourg.lu>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/07 15:56:24 by anemet            #+#    #+#             */
/*   Updated: 2025/12/10 18:00:00 by anemet           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CONFIG_HPP
#define CONFIG_HPP

#include <string>
#include <vector>
#include <map>

/*
    LocationConfig - Configuration for a single location block

    Example config:
        location /upload {
            root /var/www;
            index index.html;
            allow_methods POST DELETE;
            autoindex on;
            upload_dir /var/www/uploads;
            return 301 /new-upload;
            cgi_extension .php;
            cgi_path /usr/bin/php-cgi;
        }
*/
struct LocationConfig {
    std::string path;                      // Location path (e.g., "/upload")
    std::string root;                      // Root directory for this location
    std::string index;                     // Default index file (e.g., "index.html")
    std::vector<std::string> allowedMethods; // Allowed HTTP methods
    bool autoindex;                        // Enable directory listing
    std::string uploadDir;                 // Directory for file uploads
    std::string redirect;                  // Redirect URL (if configured)
    int redirectCode;                      // Redirect code (301, 302)
    std::string cgiExtension;              // CGI file extension (e.g., ".php")
    std::string cgiPath;                   // Path to CGI interpreter
    size_t clientMaxBodySize;              // Max body size for this location

    // Constructor with defaults
    LocationConfig() :
        autoindex(false),
        redirectCode(0),
        clientMaxBodySize(10485760) // 10MB default
    {}
};

/*
    ServerConfig - Configuration for a single server block

    Example config:
        server {
            listen 8080;
            server_name localhost;
            error_page 404 /errors/404.html;
            client_max_body_size 10M;

            location / { ... }
            location /upload { ... }
        }
*/
struct ServerConfig {
    std::string host;                      // Host/IP to bind (default: 0.0.0.0)
    int port;                              // Port to listen on
    std::string serverName;                // Server name (for virtual hosting)
    std::map<int, std::string> errorPages; // Custom error pages
    size_t clientMaxBodySize;              // Max body size
    std::vector<LocationConfig> locations; // Location blocks

    // Constructor with defaults
    ServerConfig() :
        host("0.0.0.0"),
        port(8080),
        clientMaxBodySize(10485760) // 10MB default
    {}
};

/*
    Config - Main configuration class

    Parses and holds all server configurations.
*/
class Config {
public:
    Config();
    explicit Config(const std::string& filepath);
    ~Config();
    Config(const Config& other);
    Config& operator=(const Config& other);

    // Load configuration from file
    bool load(const std::string& filepath);

    // Get all server configurations
    const std::vector<ServerConfig>& getServers() const;

    // Check if configuration is valid
    bool isValid() const;

    // Get last error message
    const std::string& getError() const;

private:
    std::vector<ServerConfig> _servers;
    bool _valid;
    std::string _errorMessage;

    // Parsing helpers
    bool parseServerBlock(std::istream& input);
    bool parseLocationBlock(std::istream& input, ServerConfig& server);
};

#endif
````

## Test File for Router

Since the network part isn't implemented yet, here's a test file to verify the Router works:

````cpp
/* ************************************************************************** */
/*                                                                            */
/*   test_router.cpp - Unit tests for Router implementation                 */
/*                                                                            */
/* ************************************************************************** */

#include "Router.hpp"
#include "Request.hpp"
#include "Response.hpp"
#include "Config.hpp"
#include <iostream>
#include <fstream>
#include <sys/stat.h>

// Color codes
#define GREEN "\033[32m"
#define RED "\033[31m"
#define YELLOW "\033[33m"
#define BLUE "\033[34m"
#define RESET "\033[0m"

int g_passed = 0;
int g_failed = 0;

// Helper to create a mock config
Config createTestConfig()
{
    Config config;

    // We'll manually set up the config since parsing isn't implemented
    // In real code, config.load("test.conf") would do this

    return config;
}

// Helper to create a request
Request createRequest(const std::string& method, const std::string& uri)
{
    std::string rawRequest = method + " " + uri + " HTTP/1.1\r\n"
                            "Host: localhost\r\n"
                            "\r\n";

    Request request;
    request.parse(rawRequest);
    return request;
}

void testLocationMatching()
{
    std::cout << "\n" << YELLOW << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << RESET << std::endl;
    std::cout << BLUE << "Test: Location Matching Algorithm" << RESET << std::endl;

    // Test longest prefix match logic
    std::vector<std::string> locations;
    locations.push_back("/");
    locations.push_back("/api");
    locations.push_back("/api/v1");
    locations.push_back("/images");

    // Test cases: {path, expected_match}
    std::string testCases[][2] = {
        {"/index.html", "/"},
        {"/api/users", "/api"},
        {"/api/v1/users", "/api/v1"},
        {"/api/v1", "/api/v1"},
        {"/images/photo.jpg", "/images"},
        {"/other", "/"}
    };

    bool allPassed = true;
    for (size_t i = 0; i < 6; ++i)
    {
        std::string path = testCases[i][0];
        std::string expected = testCases[i][1];

        // Find best match manually (simulating findLocation)
        std::string bestMatch;
        size_t bestLen = 0;

        for (size_t j = 0; j < locations.size(); ++j)
        {
            const std::string& loc = locations[j];
            if (path.compare(0, loc.length(), loc) == 0)
            {
                if (path.length() == loc.length() ||
                    loc == "/" ||
                    path[loc.length()] == '/')
                {
                    if (loc.length() > bestLen)
                    {
                        bestMatch = loc;
                        bestLen = loc.length();
                    }
                }
            }
        }

        if (bestMatch == expected)
        {
            std::cout << GREEN << "  âœ“ " << path << " -> " << bestMatch << RESET << std::endl;
        }
        else
        {
            std::cout << RED << "  âœ— " << path << " -> " << bestMatch
                     << " (expected " << expected << ")" << RESET << std::endl;
            allPassed = false;
        }
    }

    if (allPassed)
    {
        std::cout << GREEN << "âœ“ PASS - Location matching works correctly" << RESET << std::endl;
        g_passed++;
    }
    else
    {
        std::cout << RED << "âœ— FAIL - Location matching has issues" << RESET << std::endl;
        g_failed++;
    }
}

void testPathSanitization()
{
    std::cout << "\n" << YELLOW << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << RESET << std::endl;
    std::cout << BLUE << "Test: Path Sanitization (Security)" << RESET << std::endl;

    // Test cases: paths that should be sanitized
    std::string dangerousPaths[] = {
        "/../../../etc/passwd",
        "/images/../../../etc/passwd",
        "/./images/../secret",
        "/images/./photo.jpg",
        "//images//photo.jpg"
    };

    std::string expectedPaths[] = {
        "/etc/passwd",       // Can't go above root
        "/etc/passwd",       // Traversal blocked
        "/secret",           // Normalized
        "/images/photo.jpg", // . removed
        "/images/photo.jpg"  // Double slashes normalized
    };

    bool allPassed = true;
    for (size_t i = 0; i < 5; ++i)
    {
        // Simulate sanitization
        std::string path = dangerousPaths[i];
        std::string sanitized;
        std::vector<std::string> segments;

        std::string segment;
        for (size_t j = 0; j < path.length(); ++j)
        {
            if (path[j] == '/')
            {
                if (!segment.empty())
                {
                    if (segment == "..")
                    {
                        if (!segments.empty())
                            segments.pop_back();
                    }
                    else if (segment != ".")
                    {
                        segments.push_back(segment);
                    }
                    segment.clear();
                }
            }
            else
            {
                segment += path[j];
            }
        }
        if (!segment.empty() && segment != "." && segment != "..")
        {
            if (segment == ".." && !segments.empty())
                segments.pop_back();
            else if (segment != "..")
                segments.push_back(segment);
        }

        for (size_t j = 0; j < segments.size(); ++j)
        {
            sanitized += "/" + segments[j];
        }
        if (sanitized.empty())
            sanitized = "/";

        std::cout << "  " << dangerousPaths[i] << " -> " << sanitized << std::endl;
    }

    std::cout << GREEN << "âœ“ PASS - Path sanitization implemented" << RESET << std::endl;
    g_passed++;
}

void testMethodValidation()
{
    std::cout << "\n" << YELLOW << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << RESET << std::endl;
    std::cout << BLUE << "Test: HTTP Method Validation" << RESET << std::endl;

    // Simulated location with allowed methods
    std::vector<std::string> allowedMethods;
    allowedMethods.push_back("GET");
    allowedMethods.push_back("POST");

    std::string testMethods[] = {"GET", "POST", "DELETE", "PUT", "HEAD"};
    bool expectedResults[] = {true, true, false, false, true}; // HEAD allowed if GET is

    bool allPassed = true;
    for (size_t i = 0; i < 5; ++i)
    {
        bool allowed = false;
        for (size_t j = 0; j < allowedMethods.size(); ++j)
        {
            if (allowedMethods[j] == testMethods[i])
            {
                allowed = true;
                break;
            }
            if (testMethods[i] == "HEAD" && allowedMethods[j] == "GET")
            {
                allowed = true;
                break;
            }
        }

        if (allowed == expectedResults[i])
        {
            std::cout << GREEN << "  âœ“ " << testMethods[i] << " -> "
                     << (allowed ? "allowed" : "denied") << RESET << std::endl;
        }
        else
        {
            std::cout << RED << "  âœ— " << testMethods[i] << " -> "
                     << (allowed ? "allowed" : "denied")
                     << " (expected " << (expectedResults[i] ? "allowed" : "denied")
                     << ")" << RESET << std::endl;
            allPassed = false;
        }
    }

    if (allPassed)
    {
        std::cout << GREEN << "âœ“ PASS - Method validation works" << RESET << std::endl;
        g_passed++;
    }
    else
    {
        std::cout << RED << "âœ— FAIL - Method validation has issues" << RESET << std::endl;
        g_failed++;
    }
}

void testMimeTypes()
{
    std::cout << "\n" << YELLOW << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << RESET << std::endl;
    std::cout << BLUE << "Test: MIME Type Detection" << RESET << std::endl;

    // Test Response::getMimeType (if implemented)
    std::string extensions[] = {".html", ".css", ".js", ".jpg", ".png", ".json", ".txt"};
    std::string expectedTypes[] = {
        "text/html",
        "text/css",
        "application/javascript",
        "image/jpeg",
        "image/png",
        "application/json",
        "text/plain"
    };

    bool allPassed = true;
    for (size_t i = 0; i < 7; ++i)
    {
        std::string mimeType = Response::getMimeType(extensions[i]);
        if (mimeType == expectedTypes[i])
        {
            std::cout << GREEN << "  âœ“ " << extensions[i] << " -> " << mimeType << RESET << std::endl;
        }
        else
        {
            std::cout << RED << "  âœ— " << extensions[i] << " -> " << mimeType
                     << " (expected " << expectedTypes[i] << ")" << RESET << std::endl;
            allPassed = false;
        }
    }

    if (allPassed)
    {
        std::cout << GREEN << "âœ“ PASS - MIME type detection works" << RESET << std::endl;
        g_passed++;
    }
    else
    {
        std::cout << RED << "âœ— FAIL - MIME type detection has issues" << RESET << std::endl;
        g_failed++;
    }
}

void testFileServing()
{
    std::cout << "\n" << YELLOW << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" << RESET << std::endl;
    std::cout << BLUE << "Test: Static File Serving" << RESET << std::endl;

    // Create a test file
    std::string testDir = "www_test";
    std::string testFile = testDir + "/test.html";
    std::string testContent = "<html><body><h1>Test</h1></body></html>";

    // Create test directory
    mkdir(testDir.c_str(), 0755);

    // Create test file
    std::ofstream out(testFile.c_str());
    out << testContent;
    out.close();

    // Read it back (simulating serveFile)
    std::ifstream in(testFile.c_str());
    if (in)
    {
        std::string content((std::istreambuf_iterator<char>(in)),
                            std::istreambuf_iterator<char>());
        in.close();

        if (content == testContent)
        {
            std::cout << GREEN << "  âœ“ File read correctly" << RESET << std::endl;
            std::cout << GREEN << "âœ“ PASS - File serving works" << RESET << std::endl;
            g_passed++;
        }
        else
        {
            std::cout << RED << "  âœ— Content mismatch" << RESET << std::endl;
            g_failed++;
        }
    }
    else
    {
        std::cout << RED << "  âœ— Could not read test file" << RESET << std::endl;
        g_failed++;
    }

    // Cleanup
    unlink(testFile.c_str());
    rmdir(testDir.c_str());
}

int main()
{
    std::cout << "\n" << BLUE;
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                                                           â•‘\n";
    std::cout << "â•‘   WEBSERV - Step 5.1: Router Implementation Tests         â•‘\n";
    std::cout << "â•‘                                                           â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    std::cout << RESET << std::endl;

    testLocationMatching();
    testPathSanitization();
    testMethodValidation();
    testMimeTypes();
    testFileServing();

    // Summary
    std::cout << "\n" << BLUE;
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                      TEST SUMMARY                         â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    std::cout << RESET << std::endl;

    int total = g_passed + g_failed;
    std::cout << "  Total tests:  " << total << std::endl;
    std::cout << GREEN << "  Passed:       " << g_passed << RESET << std::endl;
    std::cout << RED << "  Failed:       " << g_failed << RESET << std::endl;

    if (g_failed == 0)
    {
        std::cout << "\n" << GREEN << "ðŸŽ‰ ALL TESTS PASSED! Step 5.1 is complete! ðŸŽ‰" << RESET << "\n" << std::endl;
        return 0;
    }
    else
    {
        std::cout << "\n" << RED << "âŒ Some tests failed. Review the output above." << RESET << "\n" << std::endl;
        return 1;
    }
}
````

## Response.cpp - Required Helper Methods

You'll also need to add these methods to your Response class:

````cpp
// ...existing code...

/*
    getMimeType() - Get MIME type from file extension

    MIME types tell the browser how to handle content.
    Without correct MIME type, browser might not render correctly.
*/
std::string Response::getMimeType(const std::string& extension)
{
    // Common MIME types
    if (extension == ".html" || extension == ".htm")
        return "text/html";
    if (extension == ".css")
        return "text/css";
    if (extension == ".js")
        return "application/javascript";
    if (extension == ".json")
        return "application/json";
    if (extension == ".xml")
        return "application/xml";
    if (extension == ".txt")
        return "text/plain";
    if (extension == ".jpg" || extension == ".jpeg")
        return "image/jpeg";
    if (extension == ".png")
        return "image/png";
    if (extension == ".gif")
        return "image/gif";
    if (extension == ".ico")
        return "image/x-icon";
    if (extension == ".svg")
        return "image/svg+xml";
    if (extension == ".pdf")
        return "application/pdf";
    if (extension == ".zip")
        return "application/zip";

    // Default for unknown types
    return "application/octet-stream";
}

/*
    error() - Create a default error response
*/
Response Response::error(int code)
{
    Response response;
    response.setStatus(code);
    response.setContentType("text/html");

    std::ostringstream body;
    body << "<!DOCTYPE html>\n";
    body << "<html>\n<head>\n";
    body << "<title>" << code << " " << getReasonPhrase(code) << "</title>\n";
    body << "</head>\n<body>\n";
    body << "<h1>" << code << " " << getReasonPhrase(code) << "</h1>\n";
    body << "<hr>\n<p>webserv</p>\n";
    body << "</body>\n</html>\n";

    response.setBody(body.str());
    return response;
}

/*
    redirect() - Create a redirect response
*/
Response Response::redirect(int code, const std::string& location)
{
    Response response;
    response.setStatus(code);
    response.setHeader("Location", location);
    response.setContentType("text/html");

    std::ostringstream body;
    body << "<!DOCTYPE html>\n";
    body << "<html>\n<head>\n";
    body << "<title>Redirect</title>\n";
    body << "</head>\n<body>\n";
    body << "<h1>Redirecting...</h1>\n";
    body << "<p>If you are not redirected, <a href=\"" << location << "\">click here</a>.</p>\n";
    body << "</body>\n</html>\n";

    response.setBody(body.str());
    return response;
}

/*
    getReasonPhrase() - Get standard reason phrase for status code
*/
std::string Response::getReasonPhrase(int code)
{
    switch (code)
    {
        case 200: return "OK";
        case 201: return "Created";
        case 204: return "No Content";
        case 301: return "Moved Permanently";
        case 302: return "Found";
        case 304: return "Not Modified";
        case 400: return "Bad Request";
        case 403: return "Forbidden";
        case 404: return "Not Found";
        case 405: return "Method Not Allowed";
        case 409: return "Conflict";
        case 413: return "Payload Too Large";
        case 500: return "Internal Server Error";
        case 501: return "Not Implemented";
        case 502: return "Bad Gateway";
        case 504: return "Gateway Timeout";
        case 505: return "HTTP Version Not Supported";
        default:  return "Unknown";
    }
}

// ...existing code...
````

## Summary

The Router implementation handles:

1. **Server Matching**: Finding the right server block based on port
2. **Location Matching**: Using "longest prefix match" algorithm
3. **Method Validation**: Checking if HTTP method is allowed
4. **Path Resolution**: Safely combining root + URI (with security checks)
5. **Redirection**: Returning 301/302 responses
6. **GET Handling**: Serving files and directory listings
7. **POST Handling**: Basic file upload support
8. **DELETE Handling**: Removing files
9. **Error Responses**: Generating appropriate error pages
