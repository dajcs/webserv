# Phase 3: Connection Management

I'll help you implement the Connection Management phase. This involves creating a `Connection` class to properly track and manage client connections, implementing timeouts, and integrating everything with the Server class.

## Overview

Looking at your current Server.cpp, you already have basic connection handling with the `ClientInfo` struct. We'll expand this into a proper `Connection` class that:

1. Manages connection state (reading request, sending response)
2. Buffers incoming data for HTTP parsing
3. Buffers outgoing response data for non-blocking writes
4. Tracks connection timestamps for timeout management
5. Integrates with the HTTP Request parser

Let's create the files:

---

## Connection.hpp

````cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Connection.hpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: webserv                                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/15                               #+#    #+#             */
/*   Updated: 2025/12/15                              ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CONNECTION_HPP
# define CONNECTION_HPP

/*
	=================================================================
		CONNECTION CLASS - Client Connection Management
	=================================================================

	In a web server, each client that connects creates a "connection".
	This connection has a lifecycle:

	┌─────────────────────────────────────────────────────────────────┐
	│                    CONNECTION LIFECYCLE                         │
	├─────────────────────────────────────────────────────────────────┤
	│                                                                 │
	│   1. ACCEPT                                                     │
	│      ↓                                                          │
	│      Client connects, we accept() and create Connection         │
	│      State: CONN_READING                                        │
	│                                                                 │
	│   2. READ REQUEST                                               │
	│      ↓                                                          │
	│      Read data from socket, buffer it, parse HTTP request       │
	│      May take multiple recv() calls (data arrives in chunks)    │
	│      State: CONN_READING                                        │
	│                                                                 │
	│   3. PROCESS REQUEST                                            │
	│      ↓                                                          │
	│      Route request, generate response                           │
	│      State: CONN_WRITING                                        │
	│                                                                 │
	│   4. SEND RESPONSE                                              │
	│      ↓                                                          │
	│      Write response to socket (may take multiple send() calls)  │
	│      State: CONN_WRITING                                        │
	│                                                                 │
	│   5. COMPLETE                                                   │
	│      ↓                                                          │
	│      Either:                                                    │
	│      - Close connection (HTTP/1.0 or Connection: close)         │
	│      - Reset for next request (keep-alive)                      │
	│                                                                 │
	│   TIMEOUT                                                       │
	│      ↓                                                          │
	│      If client is idle too long, close connection               │
	│      Prevents resource exhaustion from abandoned connections    │
	│                                                                 │
	└─────────────────────────────────────────────────────────────────┘

	Why Connection State Matters:
	-----------------------------
	The server uses epoll to know when sockets are ready for I/O.
	But epoll doesn't know what PHASE we're in:

	- CONN_READING: Monitor for EPOLLIN (data to read)
	- CONN_WRITING: Monitor for EPOLLOUT (ready to write)

	We track state to:
	1. Know which epoll events to watch for
	2. Know what action to take when an event occurs
	3. Handle partial reads/writes correctly

	Buffer Management:
	------------------
	HTTP data arrives/sends in unpredictable chunks:

	┌──────────────────────────────────────────────────────────────┐
	│  recv() call 1:  "GET / HTTP"                                │
	│  recv() call 2:  "/1.1\r\nHost: local"                       │
	│  recv() call 3:  "host\r\n\r\n"                              │
	│                                                              │
	│  Complete request: "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n"│
	└──────────────────────────────────────────────────────────────┘

	We buffer data until we have a complete request.
	Similarly for responses - send() might not send everything at once.

	Keep-Alive Connections:
	-----------------------
	HTTP/1.1 defaults to keep-alive: after one request/response,
	the connection stays open for more requests.

	Request 1: GET /index.html → Response 1
	Request 2: GET /style.css  → Response 2  (same TCP connection!)
	Request 3: GET /script.js  → Response 3

	This is more efficient than opening a new TCP connection each time.
	We reset the connection state after each complete response.
*/

#include <string>
#include <ctime>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

// Forward declarations
class Request;
class Response;
class Config;
struct ServerConfig;

/*
	Connection States
	-----------------
	These represent the current phase of the connection lifecycle.

	CONN_READING:  Waiting for/receiving client request data
	CONN_WRITING:  Sending response data to client
	CONN_CLOSED:   Connection is finished, ready for cleanup
	CONN_ERROR:    An error occurred, connection should be closed
*/
enum ConnectionState
{
	CONN_READING,   // Reading request from client
	CONN_WRITING,   // Writing response to client
	CONN_CLOSED,    // Connection closed normally
	CONN_ERROR      // Error occurred
};


/*
	=================================================================
		CONNECTION CLASS
	=================================================================

	Manages a single client connection from accept() to close().

	Responsibilities:
	1. Store socket file descriptor and client info
	2. Buffer incoming request data
	3. Buffer outgoing response data
	4. Track connection state and timestamps
	5. Provide interface for reading and writing
	6. Handle keep-alive connection reuse

	Thread Safety:
	--------------
	This class is NOT thread-safe. In webserv, we use a single-threaded
	event loop, so this is fine. Each connection is handled by one thread.
*/
class Connection
{
public:
	// ===========================
	//  Constructors & Destructor
	// ===========================

	/*
		Default Constructor
		Creates an invalid connection (fd = -1).
		Used for container initialization.
	*/
	Connection();

	/*
		Parameterized Constructor
		Creates a connection for an accepted client socket.

		Parameters:
			fd:         Client socket file descriptor (from accept())
			clientAddr: Client's IP address structure
			serverPort: Which port the client connected to
	*/
	Connection(int fd, const struct sockaddr_in& clientAddr, int serverPort);

	/*
		Destructor
		Does NOT close the socket - the Server class manages socket lifecycle.
		This allows connections to be copied/moved without accidentally
		closing sockets.
	*/
	~Connection();

	/*
		Copy Constructor & Assignment
		Connections can be copied for storage in containers.
		The socket is NOT duplicated - both copies reference the same fd.
	*/
	Connection(const Connection& other);
	Connection& operator=(const Connection& other);


	// ===========================
	//  Core I/O Operations
	// ===========================

	/*
		readData() - Read available data from client socket

		Called when epoll indicates EPOLLIN (data available).

		Non-blocking behavior:
		- Reads whatever data is currently available
		- Returns immediately, never blocks
		- May need multiple calls to get complete request

		Algorithm:
		1. Call recv() to get available data
		2. Append to read buffer
		3. Try to parse as HTTP request
		4. If request complete, change state to CONN_WRITING

		Returns:
			true:  Read successful (may need more data)
			false: Error or client disconnected (close connection)
	*/
	bool readData();

	/*
		writeData() - Write buffered response data to client

		Called when epoll indicates EPOLLOUT (ready to write).

		Non-blocking behavior:
		- Writes as much as the socket will accept
		- Returns immediately, never blocks
		- May need multiple calls to send complete response

		Algorithm:
		1. Call send() with remaining response data
		2. Update write position
		3. If all data sent:
		   - If keep-alive: reset for next request
		   - If not: mark as CONN_CLOSED

		Returns:
			true:  Write successful (may have more to write)
			false: Error (close connection)
	*/
	bool writeData();


	// ===========================
	//  Response Management
	// ===========================

	/*
		setResponse() - Queue a response for sending

		Called after the Router generates a response for the request.

		Parameters:
			response: The HTTP response to send

		Side effects:
		- Stores the response data in write buffer
		- Changes state to CONN_WRITING
		- Updates keep-alive flag from response
	*/
	void setResponse(const Response& response);

	/*
		hasCompleteRequest() - Check if we've received a full HTTP request

		HTTP requests end with "\r\n\r\n" (blank line after headers).
		For POST with body, we also need the complete body.

		Returns:
			true if request is complete and ready for processing
	*/
	bool hasCompleteRequest() const;


	// ===========================
	//  State Management
	// ===========================

	/*
		getState() - Get current connection state

		Used by Server to determine:
		- Which epoll events to monitor (EPOLLIN vs EPOLLOUT)
		- Whether to close the connection
	*/
	ConnectionState getState() const;

	/*
		setState() - Manually set connection state

		Usually state changes happen automatically, but sometimes
		we need to force a state (e.g., on error).
	*/
	void setState(ConnectionState state);

	/*
		reset() - Reset connection for keep-alive reuse

		After a complete request/response cycle on a keep-alive connection:
		1. Clear request/response buffers
		2. Reset state to CONN_READING
		3. Keep socket open for next request
		4. Update activity timestamp
	*/
	void reset();


	// ===========================
	//  Timeout Management
	// ===========================

	/*
		updateActivity() - Update last activity timestamp

		Called whenever we successfully read or write data.
		Used for timeout detection.
	*/
	void updateActivity();

	/*
		isTimedOut() - Check if connection has been idle too long

		Parameters:
			timeoutSeconds: Maximum idle time allowed

		Returns:
			true if connection should be closed due to inactivity
	*/
	bool isTimedOut(int timeoutSeconds) const;

	/*
		getLastActivity() - Get timestamp of last activity

		Returns:
			Unix timestamp of last read/write operation
	*/
	time_t getLastActivity() const;

	/*
		getConnectTime() - Get timestamp when connection was established

		Returns:
			Unix timestamp of when accept() was called
	*/
	time_t getConnectTime() const;


	// ===========================
	//  Getters
	// ===========================

	/*
		getFd() - Get the socket file descriptor

		Used by Server for epoll operations and socket I/O.
	*/
	int getFd() const;

	/*
		getServerPort() - Get the port client connected to

		Used for routing to the correct server configuration.
		If we listen on multiple ports (8080, 8081), we need to
		know which port this client connected to.
	*/
	int getServerPort() const;

	/*
		getClientIP() - Get client's IP address as string

		Used for logging and access control.
		Example: "192.168.1.100"
	*/
	const std::string& getClientIP() const;

	/*
		getClientPort() - Get client's port number

		The client's ephemeral port (not our server port).
		Used for logging.
	*/
	int getClientPort() const;

	/*
		getRequest() - Get the parsed HTTP request

		Returns pointer to Request object after successful parsing.
		Returns NULL if request not yet complete or parsing failed.
	*/
	Request* getRequest();
	const Request* getRequest() const;

	/*
		shouldKeepAlive() - Check if connection should stay open

		Returns:
			true if HTTP/1.1 with keep-alive (or HTTP/1.0 with explicit keep-alive)
			false if connection should close after response
	*/
	bool shouldKeepAlive() const;


	// ===========================
	//  Epoll Event Helpers
	// ===========================

	/*
		getNeededEvents() - Get epoll events needed for current state

		Returns:
			EPOLLIN  if state == CONN_READING
			EPOLLOUT if state == CONN_WRITING
			0        if connection should be closed

		Used by Server to update epoll monitoring.
	*/
	uint32_t getNeededEvents() const;

	/*
		hasDataToWrite() - Check if there's pending response data

		Returns:
			true if write buffer has unsent data
	*/
	bool hasDataToWrite() const;


private:
	// ===========================
	//  Private Members
	// ===========================

	// Socket and client information
	int					_fd;            // Client socket file descriptor
	std::string			_clientIP;      // Client IP address (for logging)
	int					_clientPort;    // Client source port
	int					_serverPort;    // Server port client connected to

	// Timestamps for timeout management
	time_t				_connectTime;   // When connection was established
	time_t				_lastActivity;  // Last successful I/O operation

	// Connection state
	ConnectionState		_state;         // Current state in lifecycle
	bool				_keepAlive;     // Keep connection open after response?

	// Buffers for HTTP data
	std::string			_readBuffer;    // Incoming data from client
	std::string			_writeBuffer;   // Outgoing data to client
	size_t				_writeOffset;   // How much of writeBuffer has been sent

	// HTTP Request object
	Request*			_request;       // Parsed HTTP request (owned by Connection)


	// ===========================
	//  Private Methods
	// ===========================

	/*
		parseRequest() - Attempt to parse buffered data as HTTP request

		Called after each read to check if we have a complete request.

		Returns:
			true if request successfully parsed
			false if need more data or parse error
	*/
	bool parseRequest();

	/*
		determineKeepAlive() - Check if connection should persist

		Examines HTTP version and Connection header to determine
		if we should keep the connection open after the response.

		HTTP/1.1: Keep-alive by default (unless Connection: close)
		HTTP/1.0: Close by default (unless Connection: keep-alive)
	*/
	void determineKeepAlive();
};

#endif
````

---

## Connection.cpp

````cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Connection.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: webserv                                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/15                               #+#    #+#             */
/*   Updated: 2025/12/15                              ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Connection.hpp"
#include "Request.hpp"
#include "Response.hpp"

#include <unistd.h>
#include <sys/socket.h>
#include <errno.h>
#include <cstring>
#include <iostream>

/*
	=================================================================
		CONNECTION IMPLEMENTATION
	=================================================================

	This file implements the Connection class, which manages individual
	client connections throughout their lifecycle.

	Key Concepts:
	-------------

	1. NON-BLOCKING I/O
	   All socket operations return immediately. If data isn't ready,
	   recv()/send() return -1 with errno = EAGAIN.
	   We use epoll to know when I/O will succeed.

	2. BUFFERING
	   Data arrives/sends in unpredictable chunks. We buffer:
	   - Incoming data until we have a complete HTTP request
	   - Outgoing data until it's all been sent

	3. STATE MACHINE
	   The connection moves through states:
	   READING → WRITING → (reset for keep-alive) or CLOSED

	4. TIMEOUT HANDLING
	   We track timestamps to detect idle connections.
	   Idle connections are closed to free resources.
*/

// =================================================================
//  CONSTANTS
// =================================================================

/*
	Buffer size for recv() calls.

	Why 8192 (8 KB)?
	- Large enough to read most small requests in one call
	- Small enough to not waste memory on many connections
	- Matches common TCP receive buffer sizes
	- HTTP headers rarely exceed 8 KB

	If request is larger, we simply call recv() multiple times.
*/
static const size_t RECV_BUFFER_SIZE = 8192;


// =================================================================
//  CONSTRUCTORS & DESTRUCTOR
// =================================================================

/*
	Default Constructor

	Creates an invalid connection with fd = -1.
	This is needed for:
	- std::map and other containers that require default construction
	- Placeholder connections before accept() succeeds
*/
Connection::Connection() :
	_fd(-1),
	_clientIP(""),
	_clientPort(0),
	_serverPort(0),
	_connectTime(0),
	_lastActivity(0),
	_state(CONN_READING),
	_keepAlive(true),
	_readBuffer(""),
	_writeBuffer(""),
	_writeOffset(0),
	_request(NULL)
{
	// Invalid connection - must be properly initialized before use
}


/*
	Parameterized Constructor

	Creates a new connection from an accepted client socket.

	Parameters:
		fd:         The client socket from accept()
		clientAddr: Client's address information
		serverPort: Which of our listening ports the client connected to

	This constructor:
	1. Stores socket and client info
	2. Initializes timestamps for timeout tracking
	3. Sets initial state to READING (waiting for request)
	4. Assumes HTTP/1.1 keep-alive by default
*/
Connection::Connection(int fd, const struct sockaddr_in& clientAddr, int serverPort) :
	_fd(fd),
	_clientPort(ntohs(clientAddr.sin_port)),
	_serverPort(serverPort),
	_state(CONN_READING),
	_keepAlive(true),  // HTTP/1.1 default
	_readBuffer(""),
	_writeBuffer(""),
	_writeOffset(0),
	_request(NULL)
{
	// Convert IP address from binary to string
	char ipBuffer[INET_ADDRSTRLEN];
	inet_ntop(AF_INET, &clientAddr.sin_addr, ipBuffer, INET_ADDRSTRLEN);
	_clientIP = ipBuffer;

	// Initialize timestamps
	_connectTime = time(NULL);
	_lastActivity = _connectTime;

	// Create a new Request object for parsing
	_request = new Request();
}


/*
	Destructor

	Cleans up dynamically allocated Request object.

	IMPORTANT: We do NOT close the socket here!
	The Server class is responsible for closing sockets.
	This allows connections to be copied (for container storage)
	without accidentally closing the socket.
*/
Connection::~Connection()
{
	if (_request != NULL)
	{
		delete _request;
		_request = NULL;
	}
}


/*
	Copy Constructor

	Creates a copy of a connection.
	Used when storing connections in std::map.

	The Request object is deep-copied (if present).
	Both copies reference the SAME socket fd.
*/
Connection::Connection(const Connection& other) :
	_fd(other._fd),
	_clientIP(other._clientIP),
	_clientPort(other._clientPort),
	_serverPort(other._serverPort),
	_connectTime(other._connectTime),
	_lastActivity(other._lastActivity),
	_state(other._state),
	_keepAlive(other._keepAlive),
	_readBuffer(other._readBuffer),
	_writeBuffer(other._writeBuffer),
	_writeOffset(other._writeOffset),
	_request(NULL)
{
	// Deep copy the request object
	if (other._request != NULL)
	{
		_request = new Request(*other._request);
	}
}


/*
	Copy Assignment Operator

	Assigns one connection to another.
	Handles self-assignment and proper cleanup.
*/
Connection& Connection::operator=(const Connection& other)
{
	if (this != &other)
	{
		// Clean up existing request
		if (_request != NULL)
		{
			delete _request;
			_request = NULL;
		}

		// Copy all members
		_fd = other._fd;
		_clientIP = other._clientIP;
		_clientPort = other._clientPort;
		_serverPort = other._serverPort;
		_connectTime = other._connectTime;
		_lastActivity = other._lastActivity;
		_state = other._state;
		_keepAlive = other._keepAlive;
		_readBuffer = other._readBuffer;
		_writeBuffer = other._writeBuffer;
		_writeOffset = other._writeOffset;

		// Deep copy request
		if (other._request != NULL)
		{
			_request = new Request(*other._request);
		}
	}
	return *this;
}


// =================================================================
//  CORE I/O OPERATIONS
// =================================================================

/*
	readData() - Read available data from client socket

	This is the main reading function, called when epoll signals EPOLLIN.

	Non-Blocking Read Process:
	--------------------------
	1. Call recv() to read whatever data is available
	2. recv() returns immediately:
	   - > 0: Got some data, append to buffer
	   - = 0: Client closed connection (EOF)
	   - < 0 with EAGAIN: No data available (would block)
	   - < 0 other: Real error

	3. After reading, try to parse the HTTP request
	4. If request is complete, change state to CONN_WRITING

	Why we buffer:
	--------------
	HTTP requests can arrive in multiple TCP packets:

	  Packet 1: "GET / HTTP/1.1\r\nHost: loc"
	  Packet 2: "alhost\r\n\r\n"

	We accumulate data in _readBuffer until we have a complete request.

	Returns:
		true:  Read successful, connection should stay open
		false: Error or disconnect, connection should be closed
*/
bool Connection::readData()
{
	// Temporary buffer for this recv() call
	char buffer[RECV_BUFFER_SIZE];

	/*
		recv(fd, buffer, length, flags)

		Receives data from a connected socket.

		Parameters:
			fd:     Socket file descriptor
			buffer: Where to store received data
			length: Maximum bytes to receive
			flags:  Usually 0 (MSG_DONTWAIT for non-blocking, but we set O_NONBLOCK)

		Returns:
			> 0: Number of bytes received
			= 0: Connection closed by peer (EOF)
			< 0: Error (check errno)

		Non-blocking behavior (since we set O_NONBLOCK):
			- If no data available, returns -1 with errno = EAGAIN
			- Never blocks, always returns immediately
	*/
	ssize_t bytesRead = recv(_fd, buffer, RECV_BUFFER_SIZE, 0);

	// =========================================
	//  Handle recv() result
	// =========================================

	if (bytesRead > 0)
	{
		/*
			Successfully received data!

			Append to our read buffer. The buffer accumulates data
			across multiple recv() calls until we have a complete request.
		*/
		_readBuffer.append(buffer, bytesRead);

		// Update activity timestamp (for timeout tracking)
		updateActivity();

		std::cout << "  [Connection fd=" << _fd << "] Received "
				  << bytesRead << " bytes (buffer now: "
				  << _readBuffer.size() << " bytes)" << std::endl;

		/*
			Try to parse the accumulated data as an HTTP request.

			parseRequest() will:
			- Feed data to the Request parser
			- Return true when request is complete
			- Return false if we need more data
		*/
		if (parseRequest())
		{
			// Request is complete! Ready to generate response.
			// State will change to CONN_WRITING when setResponse() is called.
			std::cout << "  [Connection fd=" << _fd << "] Request complete!"
					  << std::endl;
		}

		return true;  // Connection should stay open
	}
	else if (bytesRead == 0)
	{
		/*
			Client closed the connection gracefully.

			This happens when:
			- Client calls close() or shutdown()
			- Browser navigates away
			- Network connection is lost

			We should close our side too.
		*/
		std::cout << "  [Connection fd=" << _fd << "] Client disconnected (EOF)"
				  << std::endl;

		_state = CONN_CLOSED;
		return false;  // Connection should be closed
	}
	else // bytesRead < 0
	{
		/*
			recv() returned an error.

			Check errno to determine what happened:
			- EAGAIN/EWOULDBLOCK: No data available (normal for non-blocking)
			- ECONNRESET: Client forcefully closed connection
			- Other: Real error
		*/
		if (errno == EAGAIN || errno == EWOULDBLOCK)
		{
			/*
				No data available right now.

				This is NOT an error for non-blocking sockets!
				It just means there's nothing to read at this moment.
				Epoll will notify us when more data arrives.
			*/
			return true;  // Connection should stay open
		}

		/*
			Real error occurred.

			Common errors:
			- ECONNRESET: Connection reset by peer (client crashed/killed)
			- ETIMEDOUT: Connection timed out
			- ENOTCONN: Socket not connected
		*/
		std::cerr << "  [Connection fd=" << _fd << "] recv() error: "
				  << strerror(errno) << std::endl;

		_state = CONN_ERROR;
		return false;  // Connection should be closed
	}
}


/*
	writeData() - Write buffered response data to client

	This is the main writing function, called when epoll signals EPOLLOUT.

	Non-Blocking Write Process:
	---------------------------
	1. Calculate how much data remains to be sent
	2. Call send() to write as much as possible
	3. send() returns immediately:
	   - > 0: Sent some bytes, update offset
	   - = 0: Nothing sent (unusual)
	   - < 0 with EAGAIN: Buffer full, try again later
	   - < 0 other: Real error

	4. When all data is sent:
	   - If keep-alive: reset() and go back to READING
	   - If not: mark as CLOSED

	Why partial writes happen:
	--------------------------
	The kernel has limited buffer space for outgoing data.
	If we try to send 100 KB but only 16 KB fits in the buffer,
	send() returns 16384 and we try again later for the rest.

	  _writeBuffer: [====================================]
	                 ^                                   ^
	           _writeOffset                            end
	                 |<------- remaining data -------->|

	Returns:
		true:  Write successful, connection should stay open
		false: Error, connection should be closed
*/
bool Connection::writeData()
{
	// Nothing to write?
	if (_writeBuffer.empty() || _writeOffset >= _writeBuffer.size())
	{
		// All data has been sent
		// This shouldn't happen if we manage state correctly,
		// but handle it gracefully
		std::cout << "  [Connection fd=" << _fd << "] Write buffer empty"
				  << std::endl;

		return handleWriteComplete();
	}

	// Calculate remaining data to send
	size_t remaining = _writeBuffer.size() - _writeOffset;
	const char* dataPtr = _writeBuffer.c_str() + _writeOffset;

	/*
		send(fd, buffer, length, flags)

		Sends data on a connected socket.

		Parameters:
			fd:     Socket file descriptor
			buffer: Data to send
			length: Number of bytes to send
			flags:  Usually 0 or MSG_NOSIGNAL

		MSG_NOSIGNAL:
			Prevents SIGPIPE signal if client has closed.
			Without this, writing to a closed socket kills the process!

		Returns:
			> 0: Number of bytes actually sent
			= 0: Nothing sent (edge case)
			< 0: Error (check errno)

		Non-blocking behavior:
			- If kernel buffer is full, returns -1 with errno = EAGAIN
			- Never blocks, always returns immediately
	*/
	ssize_t bytesSent = send(_fd, dataPtr, remaining, MSG_NOSIGNAL);

	// =========================================
	//  Handle send() result
	// =========================================

	if (bytesSent > 0)
	{
		/*
			Successfully sent some data!

			Update offset to track progress.
			We might not have sent everything - that's fine,
			epoll will notify us when we can send more.
		*/
		_writeOffset += bytesSent;

		// Update activity timestamp
		updateActivity();

		std::cout << "  [Connection fd=" << _fd << "] Sent "
				  << bytesSent << " bytes ("
				  << _writeOffset << "/" << _writeBuffer.size() << ")"
				  << std::endl;

		// Check if we've sent everything
		if (_writeOffset >= _writeBuffer.size())
		{
			return handleWriteComplete();
		}

		return true;  // More data to send, keep connection open
	}
	else if (bytesSent == 0)
	{
		/*
			send() returned 0.

			This is rare but can happen. Just try again later.
		*/
		return true;
	}
	else // bytesSent < 0
	{
		/*
			send() returned an error.
		*/
		if (errno == EAGAIN || errno == EWOULDBLOCK)
		{
			/*
				Kernel buffer is full.

				This is normal - we're sending faster than the network.
				Epoll will notify us when buffer space is available.
			*/
			return true;  // Keep connection, try again later
		}

		/*
			Real error occurred.

			Common errors:
			- EPIPE: Client closed connection (we'd get SIGPIPE without MSG_NOSIGNAL)
			- ECONNRESET: Connection reset by peer
			- ENOTCONN: Socket not connected
		*/
		std::cerr << "  [Connection fd=" << _fd << "] send() error: "
				  << strerror(errno) << std::endl;

		_state = CONN_ERROR;
		return false;
	}
}


/*
	handleWriteComplete() - Handle successful completion of response

	Called when all response data has been sent.

	Decision logic:
	- If keep-alive: Reset connection for next request
	- If not keep-alive: Close the connection

	Returns:
		true if connection should stay open (keep-alive)
		false if connection should close
*/
bool Connection::handleWriteComplete()
{
	std::cout << "  [Connection fd=" << _fd << "] Response complete!"
			  << std::endl;

	if (_keepAlive)
	{
		/*
			HTTP Keep-Alive

			The connection stays open for more requests.
			This is efficient because:
			- No TCP handshake overhead for next request
			- Connection is already established and warm

			We reset state to read the next request.
		*/
		std::cout << "  [Connection fd=" << _fd << "] Keep-alive: waiting for next request"
				  << std::endl;

		reset();
		return true;  // Connection stays open
	}
	else
	{
		/*
			Connection: close

			Client requested (or we decided) to close after this response.
			Mark connection as closed for cleanup.
		*/
		std::cout << "  [Connection fd=" << _fd << "] Closing connection"
				  << std::endl;

		_state = CONN_CLOSED;
		return false;  // Connection should be closed
	}
}


// =================================================================
//  REQUEST PARSING
// =================================================================

/*
	parseRequest() - Feed buffered data to HTTP parser

	This function bridges the Connection's read buffer and the
	Request's incremental parser.

	The Request class handles the actual HTTP parsing.
	We just feed it data and check if it's done.

	Returns:
		true if request is complete
		false if more data is needed
*/
bool Connection::parseRequest()
{
	if (!_request)
	{
		_request = new Request();
	}

	/*
		Feed the entire read buffer to the request parser.

		The Request::parse() method is incremental:
		- It buffers data internally
		- Returns true when the request is complete
		- Returns false if more data is needed

		Note: We could be smarter and only feed new data,
		but for simplicity we feed everything.
		The Request class handles duplicates internally.
	*/
	bool complete = _request->parse(_readBuffer);

	if (complete)
	{
		/*
			Request parsing is complete!

			Now check if it succeeded or there was an error.
		*/
		if (_request->hasError())
		{
			std::cerr << "  [Connection fd=" << _fd << "] Parse error: "
					  << _request->getErrorCode() << std::endl;
			// We'll still return true - the error response will be generated
		}

		// Clear the read buffer (we've consumed the request)
		_readBuffer.clear();

		// Determine if this should be a keep-alive connection
		determineKeepAlive();

		return true;
	}

	return false;  // Need more data
}


/*
	determineKeepAlive() - Check HTTP version and headers for keep-alive

	Keep-Alive Logic:
	-----------------
	HTTP/1.1:
		- Default: keep-alive
		- Close if: Connection: close header

	HTTP/1.0:
		- Default: close
		- Keep-alive if: Connection: keep-alive header
*/
void Connection::determineKeepAlive()
{
	if (!_request || !_request->isComplete())
	{
		return;
	}

	std::string httpVersion = _request->getHttpVersion();
	std::string connectionHeader = _request->getHeader("Connection");

	// Convert to lowercase for comparison
	std::string lowerConnection = connectionHeader;
	for (size_t i = 0; i < lowerConnection.size(); ++i)
	{
		if (lowerConnection[i] >= 'A' && lowerConnection[i] <= 'Z')
		{
			lowerConnection[i] = lowerConnection[i] + 32;
		}
	}

	if (httpVersion == "HTTP/1.1")
	{
		// HTTP/1.1: keep-alive by default
		// Close only if explicitly requested
		_keepAlive = (lowerConnection != "close");
	}
	else
	{
		// HTTP/1.0: close by default
		// Keep-alive only if explicitly requested
		_keepAlive = (lowerConnection == "keep-alive");
	}

	std::cout << "  [Connection fd=" << _fd << "] Keep-alive: "
			  << (_keepAlive ? "yes" : "no")
			  << " (HTTP version: " << httpVersion << ")" << std::endl;
}


// =================================================================
//  RESPONSE MANAGEMENT
// =================================================================

/*
	setResponse() - Queue a response for sending

	Called by the Server after the Router generates a response.

	This function:
	1. Builds the complete HTTP response string
	2. Stores it in the write buffer
	3. Changes state to WRITING

	Parameters:
		response: The HTTP Response object to send
*/
void Connection::setResponse(const Response& response)
{
	/*
		Build the complete HTTP response.

		Response::build() generates:
		- Status line: "HTTP/1.1 200 OK\r\n"
		- Headers: "Content-Type: text/html\r\n..."
		- Blank line: "\r\n"
		- Body: "<html>..."
	*/
	_writeBuffer = response.build();
	_writeOffset = 0;

	// Update keep-alive from response
	_keepAlive = response.shouldKeepAlive();

	// Change state to writing
	_state = CONN_WRITING;

	std::cout << "  [Connection fd=" << _fd << "] Response queued ("
			  << _writeBuffer.size() << " bytes)" << std::endl;
}


/*
	hasCompleteRequest() - Check if request is fully received

	Used by Server to know when to route the request.
*/
bool Connection::hasCompleteRequest() const
{
	return _request && _request->isComplete();
}


// =================================================================
//  STATE MANAGEMENT
// =================================================================

ConnectionState Connection::getState() const
{
	return _state;
}

void Connection::setState(ConnectionState state)
{
	_state = state;
}


/*
	reset() - Reset connection for keep-alive reuse

	After a complete request/response cycle, prepare for the next request.

	What we keep:
	- Socket fd (connection stays open)
	- Client IP/port (client is the same)
	- Server port (still the same listener)
	- Connect time (connection was established earlier)

	What we reset:
	- Read/write buffers (fresh for new request)
	- Request object (new request incoming)
	- State (back to READING)
	- Activity timestamp (reset timeout)
*/
void Connection::reset()
{
	// Clear buffers
	_readBuffer.clear();
	_writeBuffer.clear();
	_writeOffset = 0;

	// Reset request object
	if (_request)
	{
		delete _request;
	}
	_request = new Request();

	// Reset state
	_state = CONN_READING;
	_keepAlive = true;  // Assume keep-alive for next request

	// Update activity timestamp
	updateActivity();

	std::cout << "  [Connection fd=" << _fd << "] Reset for next request"
			  << std::endl;
}


// =================================================================
//  TIMEOUT MANAGEMENT
// =================================================================

void Connection::updateActivity()
{
	_lastActivity = time(NULL);
}


/*
	isTimedOut() - Check if connection has been idle too long

	Parameters:
		timeoutSeconds: Maximum allowed idle time

	Returns:
		true if connection should be closed due to inactivity

	Timeout protects against:
	- Clients that connect but never send data
	- Clients that send partial requests and disappear
	- Slow clients (slowloris attack)
	- Abandoned keep-alive connections
*/
bool Connection::isTimedOut(int timeoutSeconds) const
{
	time_t now = time(NULL);
	time_t idleTime = now - _lastActivity;

	return (idleTime >= timeoutSeconds);
}

time_t Connection::getLastActivity() const
{
	return _lastActivity;
}

time_t Connection::getConnectTime() const
{
	return _connectTime;
}


// =================================================================
//  GETTERS
// =================================================================

int Connection::getFd() const
{
	return _fd;
}

int Connection::getServerPort() const
{
	return _serverPort;
}

const std::string& Connection::getClientIP() const
{
	return _clientIP;
}

int Connection::getClientPort() const
{
	return _clientPort;
}

Request* Connection::getRequest()
{
	return _request;
}

const Request* Connection::getRequest() const
{
	return _request;
}

bool Connection::shouldKeepAlive() const
{
	return _keepAlive;
}


// =================================================================
//  EPOLL EVENT HELPERS
// =================================================================

/*
	getNeededEvents() - Get epoll events for current state

	Returns the epoll event flags that should be monitored
	based on the current connection state.

	EPOLLIN:  Ready to read (client has data for us)
	EPOLLOUT: Ready to write (we can send data to client)
*/
uint32_t Connection::getNeededEvents() const
{
	switch (_state)
	{
		case CONN_READING:
			// Waiting for request data
			return EPOLLIN;

		case CONN_WRITING:
			// Have response data to send
			return EPOLLOUT;

		case CONN_CLOSED:
		case CONN_ERROR:
		default:
			// Connection should be closed
			return 0;
	}
}


bool Connection::hasDataToWrite() const
{
	return !_writeBuffer.empty() && _writeOffset < _writeBuffer.size();
}
````

---

## Updated Server.cpp

Now let's update the Server class to use the new Connection class properly. Here are the key changes:

````cpp
// ...existing code (includes)...

#include "Connection.hpp"
#include "Request.hpp"
#include "Response.hpp"
#include "Router.hpp"

// ...existing code until handleClientEvent...

/*
	handleClientEvent() - Process events on a client socket

	Updated to use Connection class for proper HTTP handling.

	Parameters:
		clientFd: The client socket with events
		events:   The epoll events that occurred

	Returns:
		true:  Keep the connection open
		false: Close the connection
*/
bool Server::handleClientEvent(int clientFd, uint32_t events)
{
	// Find connection info
	std::map<int, Connection>::iterator it = _connections.find(clientFd);
	if (it == _connections.end())
	{
		std::cerr << "Unknown client fd=" << clientFd << std::endl;
		return false;
	}

	Connection& conn = it->second;

	// =========================================
	//  Handle Errors and Disconnection
	// =========================================
	if (events & (EPOLLERR | EPOLLHUP))
	{
		std::cout << "  Client fd=" << clientFd;
		if (events & EPOLLERR) std::cout << " error";
		if (events & EPOLLHUP) std::cout << " hung up";
		std::cout << std::endl;
		return false;
	}

	// =========================================
	//  Handle Readable (EPOLLIN)
	// =========================================
	if (events & EPOLLIN)
	{
		// Read data from client
		if (!conn.readData())
		{
			// Read failed or client disconnected
			return false;
		}

		// Check if we have a complete request
		if (conn.hasCompleteRequest())
		{
			// Process the request and generate response
			processRequest(conn);
		}
	}

	// =========================================
	//  Handle Writable (EPOLLOUT)
	// =========================================
	if (events & EPOLLOUT)
	{
		if (conn.hasDataToWrite())
		{
			if (!conn.writeData())
			{
				// Write failed
				return false;
			}
		}
	}

	// =========================================
	//  Update Epoll Events if State Changed
	// =========================================
	uint32_t neededEvents = conn.getNeededEvents();

	if (neededEvents == 0)
	{
		// Connection should be closed
		return false;
	}

	// Update epoll to monitor the right events
	modifyEpoll(clientFd, neededEvents);

	return true;
}


/*
	processRequest() - Route request and generate response

	Called when a complete HTTP request has been received.

	This function:
	1. Gets the parsed Request from the Connection
	2. Uses the Router to generate a Response
	3. Queues the Response for sending
*/
void Server::processRequest(Connection& conn)
{
	Request* request = conn.getRequest();

	if (!request)
	{
		std::cerr << "  No request object!" << std::endl;
		Response errorResp = Response::error(500);
		conn.setResponse(errorResp);
		return;
	}

	std::cout << "  Processing: " << request->getMethod() << " "
			  << request->getPath() << std::endl;

	// Check for parsing errors
	if (request->hasError())
	{
		Response errorResp = Response::error(request->getErrorCode());
		conn.setResponse(errorResp);
		return;
	}

	// Route the request
	if (_config)
	{
		Router router(*_config);
		Response response = router.route(*request, conn.getServerPort());
		conn.setResponse(response);
	}
	else
	{
		// No config - send error
		Response errorResp = Response::error(500);
		conn.setResponse(errorResp);
	}
}


/*
	acceptNewConnection() - Updated to use Connection class
*/
int Server::acceptNewConnection(int listenFd)
{
	struct sockaddr_in clientAddr;
	socklen_t clientLen = sizeof(clientAddr);

	int clientFd = accept(listenFd, (struct sockaddr*)&clientAddr, &clientLen);

	if (clientFd < 0)
	{
		if (errno == EAGAIN || errno == EWOULDBLOCK)
		{
			return -1;
		}
		std::cerr << "accept() failed: " << strerror(errno) << std::endl;
		return -1;
	}

	// Get server port from listen socket
	const ListenSocket* listenSock = getListenSocketByFd(listenFd);
	int serverPort = listenSock ? listenSock->port : 0;

	// Set non-blocking
	if (!setNonBlocking(clientFd))
	{
		std::cerr << "Failed to set client socket non-blocking" << std::endl;
		close(clientFd);
		return -1;
	}

	// Add to epoll (initially monitor for EPOLLIN - waiting for request)
	if (!addToEpoll(clientFd, EPOLLIN))
	{
		std::cerr << "Failed to add client to epoll" << std::endl;
		close(clientFd);
		return -1;
	}

	// Create and store Connection object
	Connection conn(clientFd, clientAddr, serverPort);
	_connections[clientFd] = conn;

	std::cout << "  New connection from " << conn.getClientIP()
			  << ":" << conn.getClientPort()
			  << " (fd=" << clientFd << ", total: " << _connections.size() << ")"
			  << std::endl;

	return clientFd;
}


/*
	closeClientConnection() - Updated to use Connection map
*/
void Server::closeClientConnection(int clientFd)
{
	std::cout << "  Closing client fd=" << clientFd << std::endl;

	removeFromEpoll(clientFd);
	close(clientFd);
	_connections.erase(clientFd);

	std::cout << "  Client closed (remaining: " << _connections.size() << ")" << std::endl;
}


/*
	cleanupTimedOutConnections() - Updated to use Connection class
*/
void Server::cleanupTimedOutConnections()
{
	std::vector<int> toClose;

	for (std::map<int, Connection>::iterator it = _connections.begin();
		 it != _connections.end(); ++it)
	{
		Connection& conn = it->second;

		if (conn.isTimedOut(CONNECTION_TIMEOUT_SEC))
		{
			std::cout << "  Client fd=" << conn.getFd() << " timed out" << std::endl;
			toClose.push_back(conn.getFd());
		}
	}

	for (size_t i = 0; i < toClose.size(); ++i)
	{
		closeClientConnection(toClose[i]);
	}

	if (!toClose.empty())
	{
		std::cout << "  Cleaned up " << toClose.size() << " timed-out connection(s)" << std::endl;
	}
}

// ...existing code...
````

---

## Updated Server.hpp

Add these changes to your Server.hpp:

````cpp
// ...existing includes...

#include "Connection.hpp"

// ...existing code...

class Server
{
public:
	// ...existing public methods...

private:
	// ...existing private members...

	// Replace ClientInfo map with Connection map
	std::map<int, Connection>	_connections;  // Client connections

	// ...existing private methods...

	// Add new method for request processing
	void processRequest(Connection& conn);
};
````

---

## Summary

The Connection class provides:

1. **State Machine**: Tracks whether we're reading a request or writing a response
2. **Buffering**: Handles partial reads and writes gracefully
3. **Timeout Management**: Tracks activity timestamps for idle connection detection
4. **Keep-Alive Support**: Reuses connections for multiple HTTP requests
5. **Integration with Request/Response**: Bridges raw socket I/O with HTTP parsing

The key improvements over the basic `ClientInfo` struct:
- Proper request parsing integration
- Response buffering for non-blocking writes
- State-based epoll event management
- Keep-alive connection handling
