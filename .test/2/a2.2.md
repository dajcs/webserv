I'll help you implement Step 2.2: Poll/Select Implementation using `epoll` (recommended for Linux). Let me first examine the existing Server code to understand the current implementation. 

Read [](file:///home/anemet/webserv/src/Server.cpp#1-1), lines 1 to 300

Read [](file:///home/anemet/webserv/inc/Server.hpp#1-1), lines 1 to 200

Now let me read the rest of the Server.cpp to see the existing implementation: 

Read [](file:///home/anemet/webserv/src/Server.cpp#300-300), lines 300 to 769

Read [](file:///home/anemet/webserv/inc/Server.hpp#195-195), lines 195 to 207

Now let me check the Connection.hpp to see what's already implemented for connection management: 

Read [](file:///home/anemet/webserv/inc/Connection.hpp)

Read [](file:///home/anemet/webserv/src/Connection.cpp)

The Connection files are empty. Now I have a complete picture. Let me provide you with the Step 2.2 implementation using `epoll` for Linux (Ubuntu).

Here's the complete implementation:

## Updated Server.hpp

````cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anemet <anemet@student.42luxembourg.lu>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/07 15:57:30 by anemet            #+#    #+#             */
/*   Updated: 2025/12/15 12:00:00 by anemet           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SERVER_HPP
# define SERVER_HPP

/*
	=================================================================
		SERVER CLASS - NETWORK INFRASTRUCTURE FOR WEBSERV
	=================================================================

	The Server class is responsible for:
	1. Creating listening sockets for each configured port
	2. Managing the main event loop (epoll)
	3. Accepting new client connections
	4. Coordinating request/response handling

	=================================================================
		STEP 2.2: EPOLL-BASED EVENT LOOP
	=================================================================

	Why epoll over poll/select?
	---------------------------
	1. select():
		- Limited to 1024 file descriptors (FD_SETSIZE)
		- O(n) complexity - scans all FDs each time
		- Must rebuild FD sets after each call

	2. poll():
		- No FD limit
		- Still O(n) - kernel scans all FDs
		- Better than select, but not scalable

	3. epoll():
		- No FD limit
		- O(1) for events - only returns ready FDs
		- Maintains state in kernel - no rebuilding
		- Linux-specific (kqueue on BSD/macOS)

	For a high-performance web server, epoll is the clear choice!

	How epoll works:
	----------------
	1. epoll_create1(): Create an epoll instance (returns fd)
	2. epoll_ctl():     Add/modify/remove FDs to monitor
	3. epoll_wait():    Wait for events (blocking or timeout)

	The epoll instance maintains an "interest list" of FDs.
	When events occur, they're added to a "ready list".
	epoll_wait() returns only the FDs that have events.

	This is much more efficient than poll/select which must
	check ALL file descriptors every time!
*/

#include <string>
#include <vector>
#include <map>
#include <set>

#include "Config.hpp"

// Standard C/C++ headers
#include <iostream>		// std::cout, std::cerr for logging
#include <cstring>		// memset(), strerror()
#include <cerrno>		// errno for error codes
#include <cstdlib>		// exit()
#include <ctime>		// time() for connection timestamps

// POSIX/System headers for networking
#include <sys/socket.h>	// socket(), bind(), listen(), accept(), setsockopt()
#include <sys/types.h>	// Various type definitions
#include <netinet/in.h>	// struct sockaddr_in, INADDR_ANY, htons()
#include <arpa/inet.h>	// inet_pton(), inet_ntoa() for IP address conversion
#include <unistd.h>		// close(), fcntl()
#include <fcntl.h>		// fcntl(), O_NONBLOCK
#include <sys/epoll.h>	// epoll_create1(), epoll_ctl(), epoll_wait()


/*
	=================================================================
		EPOLL EVENT FLAGS REFERENCE
	=================================================================

	EPOLLIN:    Data available for reading (or connection waiting)
	EPOLLOUT:   Ready for writing (send buffer has space)
	EPOLLERR:   Error condition on the FD
	EPOLLHUP:   Hang up (peer closed connection)
	EPOLLRDHUP: Peer closed writing half of connection (Linux 2.6.17+)
	EPOLLET:    Edge-triggered mode (vs default level-triggered)
	EPOLLONESHOT: Disable FD after one event (must re-arm)

	Level-triggered vs Edge-triggered:
	----------------------------------
	Level-triggered (default):
		- epoll_wait() returns if FD IS ready
		- Will keep returning until condition clears
		- Safer, simpler to use

	Edge-triggered (EPOLLET):
		- epoll_wait() returns when FD BECOMES ready
		- Only one notification per state change
		- More efficient but tricky to use correctly
		- Must drain all data or you'll miss events!

	We'll use level-triggered for simplicity and safety.
*/


/*
	=================================================================
		CONSTANTS
	=================================================================
*/

// Maximum events to process in one epoll_wait() call
// This is just a buffer size, not a limit on connections
static const int MAX_EPOLL_EVENTS = 64;

// Timeout for epoll_wait() in milliseconds
// -1 = block forever (not recommended)
//  0 = return immediately (polling)
// >0 = wait up to N milliseconds
static const int EPOLL_TIMEOUT_MS = 1000;  // 1 second

// Connection timeout in seconds (for cleanup)
static const int CONNECTION_TIMEOUT_SEC = 60;


/*
	=================================================================
		SOCKET INFORMATION STRUCTURE
	=================================================================
*/
struct ListenSocket
{
	int					fd;
	std::string			host;
	int					port;
	const ServerConfig*	serverConfig;

	ListenSocket() : fd(-1), host(""), port(0), serverConfig(NULL) {}
};


/*
	=================================================================
		CLIENT CONNECTION INFO (for tracking connected clients)
	=================================================================

	We need to track information about each connected client:
	- File descriptor for communication
	- Connection timestamp for timeout handling
	- Server port they connected to (for routing)
	- Client address for logging
*/
struct ClientInfo
{
	int				fd;				// Client socket file descriptor
	time_t			connectTime;	// When connection was established
	time_t			lastActivity;	// Last read/write activity
	int				serverPort;		// Which server port they connected to
	std::string		clientIP;		// Client's IP address (for logging)
	int				clientPort;		// Client's port (for logging)

	ClientInfo() :
		fd(-1),
		connectTime(0),
		lastActivity(0),
		serverPort(0),
		clientIP(""),
		clientPort(0)
	{}
};


/*
	=================================================================
		SERVER CLASS
	=================================================================
*/
class Server
{
public:
	// =====================
	//  Constructors
	// =====================
	Server();
	explicit Server(const Config& config);
	~Server();

	// =====================
	//  Core Operations
	// =====================
	bool init();
	void run();
	void stop();

	// =====================
	//  Getters
	// =====================
	bool isRunning() const;
	const std::vector<ListenSocket>& getListenSockets() const;

	// =====================
	//  Configuration
	// =====================
	void setConfig(const Config& config);

	// =====================
	//  Epoll Access (for testing)
	// =====================
	int getEpollFd() const;
	size_t getClientCount() const;

private:
	// =====================
	//  Socket Creation (Step 2.1)
	// =====================
	int createListenSocket(const std::string& host, int port);
	bool setNonBlocking(int fd);
	void closeAllSockets();

	// =====================
	//  Epoll Management (Step 2.2)
	// =====================

	/*
		initEpoll() - Create and initialize the epoll instance

		Creates the epoll file descriptor and adds all listening
		sockets to the interest list.

		Returns: true on success, false on failure
	*/
	bool initEpoll();

	/*
		addToEpoll() - Add a file descriptor to epoll monitoring

		Parameters:
			fd:     File descriptor to monitor
			events: Event flags (EPOLLIN, EPOLLOUT, etc.)

		Returns: true on success, false on failure
	*/
	bool addToEpoll(int fd, uint32_t events);

	/*
		modifyEpoll() - Modify events for an existing FD

		Parameters:
			fd:     File descriptor already in epoll
			events: New event flags

		Returns: true on success, false on failure
	*/
	bool modifyEpoll(int fd, uint32_t events);

	/*
		removeFromEpoll() - Remove a file descriptor from epoll

		Parameters:
			fd: File descriptor to remove

		Returns: true on success, false on failure
	*/
	bool removeFromEpoll(int fd);

	/*
		closeEpoll() - Close the epoll instance
	*/
	void closeEpoll();

	// =====================
	//  Connection Handling
	// =====================

	/*
		acceptNewConnection() - Accept a new client connection

		Called when a listening socket has EPOLLIN event.

		Parameters:
			listenFd: The listening socket with pending connection

		Returns: Client FD on success, -1 on failure
	*/
	int acceptNewConnection(int listenFd);

	/*
		handleClientEvent() - Process events on a client socket

		Parameters:
			clientFd: The client socket with events
			events:   The epoll events that occurred

		Returns: true to keep connection, false to close it
	*/
	bool handleClientEvent(int clientFd, uint32_t events);

	/*
		closeClientConnection() - Clean up a client connection

		Removes from epoll, closes socket, removes from tracking.

		Parameters:
			clientFd: The client socket to close
	*/
	void closeClientConnection(int clientFd);

	/*
		cleanupTimedOutConnections() - Remove stale connections

		Called periodically to close connections that have been
		idle for too long.
	*/
	void cleanupTimedOutConnections();

	// =====================
	//  Helper Functions
	// =====================

	/*
		isListenSocket() - Check if FD is a listening socket

		Returns: true if fd is a listening socket, false otherwise
	*/
	bool isListenSocket(int fd) const;

	/*
		getListenSocketByFd() - Get ListenSocket info by FD

		Returns: Pointer to ListenSocket, or NULL if not found
	*/
	const ListenSocket* getListenSocketByFd(int fd) const;

	// =====================
	//  Member Variables
	// =====================
	const Config*				_config;
	std::vector<ListenSocket>	_listenSockets;
	bool						_running;

	// Epoll-specific members
	int							_epollFd;		// Epoll instance FD
	std::map<int, ClientInfo>	_clients;		// Active client connections
	std::set<int>				_listenFds;		// Set of listening FDs (for quick lookup)

	// =====================
	//  Disabled Operations
	// =====================
	Server(const Server& other);
	Server& operator=(const Server& other);
};

#endif // SERVER_HPP
````

## Updated Server.cpp (Epoll Implementation)

````cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anemet <anemet@student.42luxembourg.lu>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/07 15:54:52 by anemet            #+#    #+#             */
/*   Updated: 2025/12/15 12:00:00 by anemet           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"


/*
	=================================================================
		SOCKET PROGRAMMING CONCEPTS (from Step 2.1)
	=================================================================

	1. FILE DESCRIPTORS (fd)
	------------------------
	When we create a socket, we get an fd like 3, 4, 5, etc.
	(0, 1, 2 are reserved for stdin, stdout, stderr)

	2. ADDRESS FAMILY (AF_INET)
	---------------------------
	AF_INET = IPv4 Internet protocols

	3. SOCKET TYPE (SOCK_STREAM)
	----------------------------
	SOCK_STREAM = TCP (reliable, ordered, connection-based)

	4. BYTE ORDER (htons, htonl)
	----------------------------
	Network byte order is BIG-ENDIAN.
	htons() = Host TO Network Short (16-bit, for ports)
	htonl() = Host TO Network Long (32-bit, for IP addresses)
*/


/*
	=================================================================
		EPOLL CONCEPTS (Step 2.2)
	=================================================================

	What is epoll?
	--------------
	epoll is a Linux-specific I/O event notification mechanism.
	It's designed for applications that need to monitor many file
	descriptors efficiently (like web servers).

	The Three Epoll Syscalls:
	-------------------------

	1. epoll_create1(flags)
		- Creates a new epoll instance
		- Returns a file descriptor for the instance
		- flags: 0 or EPOLL_CLOEXEC (close on exec)
		- The returned fd must be closed with close()

	2. epoll_ctl(epfd, op, fd, event)
		- Controls the epoll instance
		- epfd: epoll file descriptor from epoll_create1
		- op: EPOLL_CTL_ADD, EPOLL_CTL_MOD, or EPOLL_CTL_DEL
		- fd: file descriptor to add/modify/remove
		- event: pointer to epoll_event struct

	3. epoll_wait(epfd, events, maxevents, timeout)
		- Waits for events on the epoll instance
		- epfd: epoll file descriptor
		- events: array to store returned events
		- maxevents: max events to return
		- timeout: -1 block, 0 return immediately, >0 wait ms
		- Returns: number of ready FDs, 0 on timeout, -1 on error

	The epoll_event Structure:
	--------------------------
	struct epoll_event {
		uint32_t     events;    // Epoll events (EPOLLIN, EPOLLOUT, etc.)
		epoll_data_t data;      // User data variable
	};

	The data field is a union - we typically use data.fd to store
	the file descriptor, so we know which FD triggered the event.

	Why is epoll faster than poll/select?
	-------------------------------------
	1. Kernel maintains the interest list - no copying every call
	2. Only returns FDs that are ready - O(1) per event
	3. Uses efficient red-black tree internally
	4. Edge-triggered mode avoids redundant notifications
*/


// =================================================================
//  CONSTRUCTORS AND DESTRUCTOR
// =================================================================

Server::Server() :
	_config(NULL),
	_running(false),
	_epollFd(-1)
{
}

Server::Server(const Config& config) :
	_config(&config),
	_running(false),
	_epollFd(-1)
{
}

Server::~Server()
{
	stop();
}


// =================================================================
//  CONFIGURATION
// =================================================================

void Server::setConfig(const Config& config)
{
	_config = &config;
}


// =================================================================
//  INITIALIZATION
// =================================================================

bool Server::init()
{
	// =========================================
	//  Step 1: Validate Configuration
	// =========================================
	if (!_config)
	{
		std::cerr << "Error: No configuration provided" << std::endl;
		return false;
	}

	const std::vector<ServerConfig>& servers = _config->getServers();

	if (servers.empty())
	{
		std::cerr << "Error: No server blocks in configuration" << std::endl;
		return false;
	}

	std::cout << "\n=== Initializing Server ===" << std::endl;
	std::cout << "Found " << servers.size() << " server block(s) in configuration\n" << std::endl;

	// =========================================
	//  Step 2: Create Listening Sockets
	// =========================================
	std::map<std::string, size_t> socketMap;

	for (size_t i = 0; i < servers.size(); ++i)
	{
		const ServerConfig& serverConfig = servers[i];

		std::stringstream keyStream;
		keyStream << serverConfig.host << ":" << serverConfig.port;
		std::string key = keyStream.str();

		std::cout << "Processing server block " << (i + 1)
					<< ": " << key << std::endl;

		if (socketMap.find(key) != socketMap.end())
		{
			std::cout << "  -> Already listening on " << key
						<< " (reusing existing socket)" << std::endl;
			continue;
		}

		int sockfd = createListenSocket(serverConfig.host, serverConfig.port);

		if (sockfd < 0)
		{
			std::cerr << "Error: Failed to create socket for " << key << std::endl;
			closeAllSockets();
			return false;
		}

		ListenSocket listenSocket;
		listenSocket.fd = sockfd;
		listenSocket.host = serverConfig.host;
		listenSocket.port = serverConfig.port;
		listenSocket.serverConfig = &serverConfig;

		_listenSockets.push_back(listenSocket);
		_listenFds.insert(sockfd);  // Add to quick lookup set
		socketMap[key] = _listenSockets.size() - 1;

		std::cout << "  -> Created socket fd=" << sockfd
					<< " for " << key << std::endl;
	}

	// =========================================
	//  Step 3: Initialize Epoll (NEW in 2.2)
	// =========================================
	if (!initEpoll())
	{
		std::cerr << "Error: Failed to initialize epoll" << std::endl;
		closeAllSockets();
		return false;
	}

	// =========================================
	//  Step 4: Report Success
	// =========================================
	std::cout << "\n=== Server Initialized ===" << std::endl;
	std::cout << "Listening on " << _listenSockets.size() << " socket(s):" << std::endl;

	for (size_t i = 0; i < _listenSockets.size(); ++i)
	{
		std::cout << "  - http://" << _listenSockets[i].host
					<< ":" << _listenSockets[i].port
					<< " (fd=" << _listenSockets[i].fd << ")" << std::endl;
	}
	std::cout << "\nEpoll fd=" << _epollFd << " initialized" << std::endl;
	std::cout << std::endl;

	return true;
}


// =================================================================
//  EPOLL INITIALIZATION (Step 2.2 - NEW!)
// =================================================================

/*
	initEpoll() - Create and configure the epoll instance

	This function:
	1. Creates the epoll instance using epoll_create1()
	2. Adds all listening sockets to the epoll interest list
	3. Sets up monitoring for incoming connections (EPOLLIN)

	Why EPOLLIN for listening sockets?
	----------------------------------
	For a listening socket, EPOLLIN means "a connection is waiting".
	When epoll_wait() returns with EPOLLIN on a listening socket,
	we call accept() to get the new client connection.

	Returns:
		true:  Epoll initialized successfully
		false: Failed to create/configure epoll
*/
bool Server::initEpoll()
{
	std::cout << "\n--- Initializing Epoll ---" << std::endl;

	// =========================================
	//  Step 1: Create Epoll Instance
	// =========================================
	/*
		epoll_create1(flags)

		Creates a new epoll instance and returns a file descriptor.

		flags:
			0:             Standard behavior
			EPOLL_CLOEXEC: Close FD automatically on exec()

		The returned file descriptor is used for all subsequent
		epoll operations. It must be closed with close() when done.

		Note: epoll_create(size) is deprecated. epoll_create1()
		ignores the size hint and is the modern API.

		Returns:
			>= 0: Valid epoll file descriptor
			-1:   Error (check errno)

		Common errors:
			EMFILE: Process file table full
			ENFILE: System file table full
			ENOMEM: Insufficient kernel memory
	*/
	_epollFd = epoll_create1(0);

	if (_epollFd < 0)
	{
		std::cerr << "epoll_create1() failed: " << strerror(errno) << std::endl;
		return false;
	}

	std::cout << "  [1/2] epoll_create1() -> fd=" << _epollFd << std::endl;

	// =========================================
	//  Step 2: Add Listening Sockets to Epoll
	// =========================================
	/*
		For each listening socket, we add it to epoll with:
		- EPOLLIN: Notify us when connections are waiting

		When a client connects, the listening socket becomes
		"readable" - meaning accept() will succeed.
	*/
	for (size_t i = 0; i < _listenSockets.size(); ++i)
	{
		int listenFd = _listenSockets[i].fd;

		if (!addToEpoll(listenFd, EPOLLIN))
		{
			std::cerr << "Failed to add listening socket " << listenFd
						<< " to epoll" << std::endl;
			closeEpoll();
			return false;
		}

		std::cout << "  [2/2] Added listen socket fd=" << listenFd
					<< " to epoll (port " << _listenSockets[i].port << ")"
					<< std::endl;
	}

	std::cout << "--- Epoll Initialized ---\n" << std::endl;
	return true;
}


/*
	addToEpoll() - Add a file descriptor to epoll monitoring

	Uses EPOLL_CTL_ADD to register a new FD with epoll.

	The epoll_event structure:
	--------------------------
	struct epoll_event {
		uint32_t events;      // Events to monitor
		epoll_data_t data;    // User data (we use data.fd)
	};

	We store the FD in data.fd so that when epoll_wait() returns
	an event, we know which FD it's for.

	Parameters:
		fd:     File descriptor to monitor
		events: Event flags (EPOLLIN, EPOLLOUT, etc.)

	Returns:
		true:  Successfully added
		false: Failed to add
*/
bool Server::addToEpoll(int fd, uint32_t events)
{
	struct epoll_event ev;

	/*
		Initialize the epoll_event structure

		events: What events to monitor
			EPOLLIN  - Ready for reading
			EPOLLOUT - Ready for writing
			EPOLLERR - Error occurred (always monitored)
			EPOLLHUP - Hang up occurred (always monitored)

		data.fd: Store the FD so we can identify it later
	*/
	ev.events = events;
	ev.data.fd = fd;

	/*
		epoll_ctl(epfd, op, fd, event)

		EPOLL_CTL_ADD: Register the target fd with epoll
		EPOLL_CTL_MOD: Change the event for registered fd
		EPOLL_CTL_DEL: Remove (deregister) fd from epoll

		Returns 0 on success, -1 on error

		Common errors:
			EBADF:  Invalid fd or epfd
			EEXIST: fd already registered (for ADD)
			ENOENT: fd not registered (for MOD/DEL)
			ENOMEM: No memory available
	*/
	if (epoll_ctl(_epollFd, EPOLL_CTL_ADD, fd, &ev) < 0)
	{
		std::cerr << "epoll_ctl(ADD) failed for fd=" << fd
					<< ": " << strerror(errno) << std::endl;
		return false;
	}

	return true;
}


/*
	modifyEpoll() - Change the events monitored for an FD

	Used when we need to change what we're watching for.
	Example: After reading a request, we want to wait for
	write-ready to send the response.

	Parameters:
		fd:     File descriptor already in epoll
		events: New event flags

	Returns:
		true:  Successfully modified
		false: Failed to modify
*/
bool Server::modifyEpoll(int fd, uint32_t events)
{
	struct epoll_event ev;
	ev.events = events;
	ev.data.fd = fd;

	if (epoll_ctl(_epollFd, EPOLL_CTL_MOD, fd, &ev) < 0)
	{
		std::cerr << "epoll_ctl(MOD) failed for fd=" << fd
					<< ": " << strerror(errno) << std::endl;
		return false;
	}

	return true;
}


/*
	removeFromEpoll() - Remove an FD from epoll monitoring

	Called before closing a socket to clean up the epoll state.

	Note: Since Linux 2.6.9, closing an FD automatically removes
	it from epoll. But explicit removal is good practice and
	makes the code clearer.

	Parameters:
		fd: File descriptor to remove

	Returns:
		true:  Successfully removed
		false: Failed to remove
*/
bool Server::removeFromEpoll(int fd)
{
	/*
		For EPOLL_CTL_DEL, the event parameter is ignored
		since Linux 2.6.9, but we pass a valid pointer
		for compatibility with older kernels.
	*/
	struct epoll_event ev;
	ev.events = 0;
	ev.data.fd = fd;

	if (epoll_ctl(_epollFd, EPOLL_CTL_DEL, fd, &ev) < 0)
	{
		// ENOENT is okay - fd might already be removed
		if (errno != ENOENT)
		{
			std::cerr << "epoll_ctl(DEL) failed for fd=" << fd
						<< ": " << strerror(errno) << std::endl;
			return false;
		}
	}

	return true;
}


/*
	closeEpoll() - Close the epoll instance

	Releases the epoll file descriptor.
	Should be called during shutdown.
*/
void Server::closeEpoll()
{
	if (_epollFd >= 0)
	{
		std::cout << "Closing epoll fd=" << _epollFd << std::endl;
		close(_epollFd);
		_epollFd = -1;
	}
}


// =================================================================
//  MAIN EVENT LOOP (Step 2.2 - The Heart of the Server!)
// =================================================================

/*
	run() - The main server event loop

	This is where the magic happens! The event loop:
	1. Waits for events using epoll_wait()
	2. Processes each event:
		- Listening socket: Accept new connection
		- Client socket: Handle read/write/errors
	3. Periodically cleans up timed-out connections
	4. Repeats until stop() is called

	The Event Loop Pattern:
	-----------------------
	┌────────────────────────────────────────────┐
	│                                            │
	│    ┌─────────────────────────────────┐     │
	│    │      epoll_wait()               │     │
	│    │  (blocks until events ready)    │     │
	│    └─────────────────────────────────┘     │
	│                   │                        │
	│                   ▼                        │
	│    ┌─────────────────────────────────┐     │
	│    │    For each ready FD:           │     │
	│    │    - Is it a listen socket?     │     │
	│    │      → accept() new connection  │     │
	│    │    - Is it a client socket?     │     │
	│    │      → handle read/write        │     │
	│    └─────────────────────────────────┘     │
	│                   │                        │
	│                   ▼                        │
	│    ┌─────────────────────────────────┐     │
	│    │    Cleanup timed-out clients    │     │
	│    └─────────────────────────────────┘     │
	│                   │                        │
	│                   ▼                        │
	│              Loop back                     │
	│                                            │
	└────────────────────────────────────────────┘

	This is non-blocking:
	- We never wait for a single client
	- All I/O happens only when ready
	- Thousands of clients can be handled efficiently
*/
void Server::run()
{
	// Validate we're ready to run
	if (_listenSockets.empty())
	{
		std::cerr << "Error: No listening sockets. Call init() first." << std::endl;
		return;
	}

	if (_epollFd < 0)
	{
		std::cerr << "Error: Epoll not initialized. Call init() first." << std::endl;
		return;
	}

	_running = true;
	std::cout << "\n=== Server Running (epoll event loop) ===" << std::endl;
	std::cout << "Press Ctrl+C to stop\n" << std::endl;

	/*
		Event buffer for epoll_wait()

		epoll_wait() fills this array with events that occurred.
		We process MAX_EPOLL_EVENTS at a time, but there could
		be more - they'll be returned in the next call.
	*/
	struct epoll_event events[MAX_EPOLL_EVENTS];

	/*
		Track time for periodic cleanup
		We don't want to check timeouts on every loop iteration
		(that would be wasteful), so we do it every few seconds.
	*/
	time_t lastCleanup = time(NULL);
	const int CLEANUP_INTERVAL_SEC = 10;

	// =========================================
	//  THE MAIN EVENT LOOP
	// =========================================
	while (_running)
	{
		/*
			epoll_wait(epfd, events, maxevents, timeout)

			Waits for events on the epoll instance.

			Parameters:
				epfd:      Epoll file descriptor
				events:    Array to store returned events
				maxevents: Maximum events to return (buffer size)
				timeout:   -1 = block forever
				           0  = return immediately (polling)
				           >0 = wait up to N milliseconds

			Returns:
				>0: Number of FDs with events
				0:  Timeout occurred (no events)
				-1: Error occurred

			The returned events array contains:
				events[i].events: What happened (EPOLLIN, EPOLLOUT, etc.)
				events[i].data.fd: Which file descriptor

			NOTE: We use a timeout so the loop can check _running
			periodically and handle cleanup. Without timeout,
			Ctrl+C might not work smoothly.
		*/
		int numEvents = epoll_wait(_epollFd, events, MAX_EPOLL_EVENTS, EPOLL_TIMEOUT_MS);

		// Handle epoll_wait errors
		if (numEvents < 0)
		{
			// EINTR means interrupted by signal (e.g., Ctrl+C)
			// This is normal and we should just continue
			if (errno == EINTR)
			{
				std::cout << "epoll_wait interrupted by signal" << std::endl;
				continue;
			}

			// Other errors are real problems
			std::cerr << "epoll_wait() failed: " << strerror(errno) << std::endl;
			break;
		}

		// Log event count (useful for debugging, can be removed later)
		if (numEvents > 0)
		{
			std::cout << "[epoll] " << numEvents << " event(s) ready" << std::endl;
		}

		// =========================================
		//  Process Each Event
		// =========================================
		for (int i = 0; i < numEvents; ++i)
		{
			int fd = events[i].data.fd;
			uint32_t eventMask = events[i].events;

			// Log the event (for debugging)
			std::cout << "  Event on fd=" << fd << ": ";
			if (eventMask & EPOLLIN)  std::cout << "EPOLLIN ";
			if (eventMask & EPOLLOUT) std::cout << "EPOLLOUT ";
			if (eventMask & EPOLLERR) std::cout << "EPOLLERR ";
			if (eventMask & EPOLLHUP) std::cout << "EPOLLHUP ";
			std::cout << std::endl;

			// -----------------------------------------
			//  Case 1: Event on a LISTENING socket
			// -----------------------------------------
			if (isListenSocket(fd))
			{
				/*
					A listening socket has EPOLLIN = connection waiting
					We need to accept() the new connection.

					NOTE: There might be multiple connections waiting!
					In level-triggered mode, epoll will notify us again
					if there are more. In edge-triggered mode, we'd need
					to loop until accept() returns EAGAIN.
				*/
				if (eventMask & EPOLLIN)
				{
					int clientFd = acceptNewConnection(fd);
					if (clientFd >= 0)
					{
						std::cout << "  -> Accepted new client fd=" << clientFd << std::endl;
					}
				}

				// Handle errors on listening socket (rare but possible)
				if (eventMask & (EPOLLERR | EPOLLHUP))
				{
					std::cerr << "Error on listening socket fd=" << fd << std::endl;
					// Don't close listen socket - try to recover
				}
			}
			// -----------------------------------------
			//  Case 2: Event on a CLIENT socket
			// -----------------------------------------
			else
			{
				/*
					Client socket events:
					- EPOLLIN:  Data available to read
					- EPOLLOUT: Ready to write (buffer has space)
					- EPOLLERR: Error on socket
					- EPOLLHUP: Client disconnected
				*/
				bool keepConnection = handleClientEvent(fd, eventMask);

				if (!keepConnection)
				{
					closeClientConnection(fd);
				}
			}
		}

		// =========================================
		//  Periodic Cleanup
		// =========================================
		time_t now = time(NULL);
		if (now - lastCleanup >= CLEANUP_INTERVAL_SEC)
		{
			cleanupTimedOutConnections();
			lastCleanup = now;
		}
	}

	std::cout << "\n=== Event Loop Ended ===" << std::endl;
}


// =================================================================
//  CONNECTION HANDLING
// =================================================================

/*
	acceptNewConnection() - Accept an incoming client connection

	Called when a listening socket has EPOLLIN (connection waiting).

	The accept() call:
	------------------
	accept(sockfd, addr, addrlen)

	Parameters:
		sockfd:  Listening socket
		addr:    Where to store client's address
		addrlen: Size of addr buffer (in/out parameter)

	Returns:
		>= 0: New socket FD for this client
		-1:   Error (check errno)

	IMPORTANT: The returned socket is a NEW file descriptor.
	The original listening socket continues to listen.

	We then:
	1. Set the new socket to non-blocking mode
	2. Add it to epoll for monitoring
	3. Store client info for tracking

	Parameters:
		listenFd: The listening socket with pending connection

	Returns:
		>= 0: Client socket FD
		-1:   Error (connection not accepted)
*/
int Server::acceptNewConnection(int listenFd)
{
	// Prepare to store client's address
	struct sockaddr_in clientAddr;
	socklen_t clientLen = sizeof(clientAddr);

	/*
		accept() creates a new connected socket

		The new socket:
		- Has its own file descriptor
		- Is connected to the specific client
		- Inherits some properties from listening socket

		The listening socket:
		- Continues listening for more connections
		- Is not affected by this call
	*/
	int clientFd = accept(listenFd, (struct sockaddr*)&clientAddr, &clientLen);

	if (clientFd < 0)
	{
		// EAGAIN/EWOULDBLOCK = no connection ready (normal in non-blocking mode)
		if (errno == EAGAIN || errno == EWOULDBLOCK)
		{
			return -1;  // Not an error, just no connection ready
		}

		std::cerr << "accept() failed: " << strerror(errno) << std::endl;
		return -1;
	}

	// Get client info for logging
	char clientIP[INET_ADDRSTRLEN];
	inet_ntop(AF_INET, &clientAddr.sin_addr, clientIP, INET_ADDRSTRLEN);
	int clientPort = ntohs(clientAddr.sin_port);

	std::cout << "  New connection from " << clientIP << ":" << clientPort
				<< " (fd=" << clientFd << ")" << std::endl;

	// =========================================
	//  Step 1: Set Non-Blocking Mode
	// =========================================
	/*
		CRITICAL: Client sockets MUST be non-blocking!

		If we don't set non-blocking:
		- recv() could block waiting for data
		- send() could block if buffer is full
		- The entire server would freeze!

		With non-blocking:
		- recv()/send() return immediately
		- If not ready: errno = EAGAIN
		- We use epoll to know when ready
	*/
	if (!setNonBlocking(clientFd))
	{
		std::cerr << "Failed to set client socket non-blocking" << std::endl;
		close(clientFd);
		return -1;
	}

	// =========================================
	//  Step 2: Add to Epoll
	// =========================================
	/*
		Monitor the client socket for:
		- EPOLLIN: Data available to read (client sent something)

		We don't monitor EPOLLOUT yet because:
		- We haven't read the request yet
		- EPOLLOUT would trigger immediately (buffer is empty)
		- We'll add EPOLLOUT when we have data to send
	*/
	if (!addToEpoll(clientFd, EPOLLIN))
	{
		std::cerr << "Failed to add client to epoll" << std::endl;
		close(clientFd);
		return -1;
	}

	// =========================================
	//  Step 3: Store Client Info
	// =========================================
	/*
		Track this connection:
		- For timeout management
		- For logging/debugging
		- For routing to correct server config
	*/
	const ListenSocket* listenSock = getListenSocketByFd(listenFd);

	ClientInfo clientInfo;
	clientInfo.fd = clientFd;
	clientInfo.connectTime = time(NULL);
	clientInfo.lastActivity = time(NULL);
	clientInfo.serverPort = listenSock ? listenSock->port : 0;
	clientInfo.clientIP = clientIP;
	clientInfo.clientPort = clientPort;

	_clients[clientFd] = clientInfo;

	std::cout << "  Client fd=" << clientFd << " added to epoll (total clients: "
				<< _clients.size() << ")" << std::endl;

	return clientFd;
}


/*
	handleClientEvent() - Process events on a client socket

	This is where we handle actual client communication.
	For Step 2.2, we implement a simple echo/demo.
	Full HTTP handling comes in later steps.

	Parameters:
		clientFd: The client socket with events
		events:   The epoll events that occurred

	Returns:
		true:  Keep the connection open
		false: Close the connection
*/
bool Server::handleClientEvent(int clientFd, uint32_t events)
{
	// Find client info
	std::map<int, ClientInfo>::iterator it = _clients.find(clientFd);
	if (it == _clients.end())
	{
		std::cerr << "Unknown client fd=" << clientFd << std::endl;
		return false;  // Close unknown connections
	}

	ClientInfo& client = it->second;

	// =========================================
	//  Handle Errors and Disconnection
	// =========================================
	/*
		EPOLLERR: Error on socket
		EPOLLHUP: Client hung up (disconnected)

		These events always close the connection.
	*/
	if (events & (EPOLLERR | EPOLLHUP))
	{
		std::cout << "  Client fd=" << clientFd;
		if (events & EPOLLERR) std::cout << " error";
		if (events & EPOLLHUP) std::cout << " hung up";
		std::cout << std::endl;
		return false;  // Close connection
	}

	// =========================================
	//  Handle Readable (EPOLLIN)
	// =========================================
	/*
		Client sent data - read it!

		For Step 2.2, we do a simple read and send a demo response.
		Full HTTP parsing comes in Step 4 (Request.cpp).
	*/
	if (events & EPOLLIN)
	{
		char buffer[4096];
		ssize_t bytesRead = recv(clientFd, buffer, sizeof(buffer) - 1, 0);

		if (bytesRead < 0)
		{
			// EAGAIN = no data ready (shouldn't happen after EPOLLIN)
			if (errno == EAGAIN || errno == EWOULDBLOCK)
			{
				return true;  // Keep connection, try again later
			}

			std::cerr << "  recv() error on fd=" << clientFd
						<< ": " << strerror(errno) << std::endl;
			return false;  // Close on error
		}

		if (bytesRead == 0)
		{
			// Client closed connection gracefully
			std::cout << "  Client fd=" << clientFd << " closed connection" << std::endl;
			return false;
		}

		// Update activity timestamp
		client.lastActivity = time(NULL);

		// Null-terminate for printing (assuming text data)
		buffer[bytesRead] = '\0';

		std::cout << "  Received " << bytesRead << " bytes from fd=" << clientFd << std::endl;
		std::cout << "  Data: " << buffer << std::endl;

		// =========================================
		//  Demo Response (Step 2.2)
		// =========================================
		/*
			Send a simple HTTP response to prove the server works.
			In later steps, Router.cpp will generate proper responses.
		*/
		const char* response =
			"HTTP/1.1 200 OK\r\n"
			"Content-Type: text/html\r\n"
			"Content-Length: 126\r\n"
			"Connection: close\r\n"
			"\r\n"
			"<html><body>"
			"<h1>Welcome to Webserv!</h1>"
			"<p>Step 2.2: Epoll event loop is working!</p>"
			"<p>Connection handled successfully.</p>"
			"</body></html>";

		ssize_t bytesSent = send(clientFd, response, strlen(response), 0);

		if (bytesSent < 0)
		{
			std::cerr << "  send() error: " << strerror(errno) << std::endl;
		}
		else
		{
			std::cout << "  Sent " << bytesSent << " bytes to fd=" << clientFd << std::endl;
		}

		// Close connection after response (HTTP/1.0 style for demo)
		// In full implementation, check Connection: keep-alive header
		return false;
	}

	// =========================================
	//  Handle Writable (EPOLLOUT)
	// =========================================
	/*
		Socket is ready for writing.
		Used when we have buffered data to send.

		For Step 2.2, we don't use this - we send immediately.
		In full implementation, large responses are buffered.
	*/
	if (events & EPOLLOUT)
	{
		// For now, just log it
		std::cout << "  fd=" << clientFd << " is writable" << std::endl;
	}

	return true;  // Keep connection open
}


/*
	closeClientConnection() - Clean up a client connection

	Properly closes a client connection:
	1. Remove from epoll (stop monitoring)
	2. Close the socket (release FD)
	3. Remove from client tracking map
*/
void Server::closeClientConnection(int clientFd)
{
	std::cout << "  Closing client fd=" << clientFd << std::endl;

	// Remove from epoll first (before closing FD)
	removeFromEpoll(clientFd);

	// Close the socket
	close(clientFd);

	// Remove from tracking
	_clients.erase(clientFd);

	std::cout << "  Client closed (remaining: " << _clients.size() << ")" << std::endl;
}


/*
	cleanupTimedOutConnections() - Remove stale connections

	Connections that have been idle for too long are closed.
	This prevents resource exhaustion from abandoned connections.

	Called periodically from the main event loop.
*/
void Server::cleanupTimedOutConnections()
{
	time_t now = time(NULL);
	std::vector<int> toClose;

	// Find timed-out connections
	for (std::map<int, ClientInfo>::iterator it = _clients.begin();
			it != _clients.end(); ++it)
	{
		const ClientInfo& client = it->second;

		if (now - client.lastActivity > CONNECTION_TIMEOUT_SEC)
		{
			std::cout << "  Client fd=" << client.fd << " timed out ("
						<< (now - client.lastActivity) << " seconds idle)" << std::endl;
			toClose.push_back(client.fd);
		}
	}

	// Close timed-out connections
	for (size_t i = 0; i < toClose.size(); ++i)
	{
		closeClientConnection(toClose[i]);
	}

	if (!toClose.empty())
	{
		std::cout << "  Cleaned up " << toClose.size() << " timed-out connection(s)" << std::endl;
	}
}


// =================================================================
//  HELPER FUNCTIONS
// =================================================================

/*
	isListenSocket() - Check if FD is a listening socket

	Quick lookup using the _listenFds set.
*/
bool Server::isListenSocket(int fd) const
{
	return _listenFds.find(fd) != _listenFds.end();
}


/*
	getListenSocketByFd() - Find ListenSocket info by file descriptor
*/
const ListenSocket* Server::getListenSocketByFd(int fd) const
{
	for (size_t i = 0; i < _listenSockets.size(); ++i)
	{
		if (_listenSockets[i].fd == fd)
		{
			return &_listenSockets[i];
		}
	}
	return NULL;
}


// =================================================================
//  SOCKET CREATION (from Step 2.1)
// =================================================================

int Server::createListenSocket(const std::string& host, int port)
{
	// Step 1: Create Socket
	int sockfd = socket(AF_INET, SOCK_STREAM, 0);

	if (sockfd < 0)
	{
		std::cerr << "socket() failed: " << strerror(errno) << std::endl;
		return -1;
	}

	std::cout << "  [1/5] socket() created fd=" << sockfd << std::endl;

	// Step 2: Set Socket Options
	int optval = 1;

	if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0)
	{
		std::cerr << "setsockopt(SO_REUSEADDR) failed: " << strerror(errno) << std::endl;
		close(sockfd);
		return -1;
	}

	std::cout << "  [2/5] setsockopt(SO_REUSEADDR) enabled" << std::endl;

#ifdef SO_REUSEPORT
	if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval)) < 0)
	{
		std::cout << "  [*] setsockopt(SO_REUSEPORT) not available (optional)" << std::endl;
	}
	else
	{
		std::cout << "  [*] setsockopt(SO_REUSEPORT) enabled" << std::endl;
	}
#endif

	// Step 3: Prepare Address Structure
	struct sockaddr_in serverAddr;
	memset(&serverAddr, 0, sizeof(serverAddr));

	serverAddr.sin_family = AF_INET;
	serverAddr.sin_port = htons(port);

	if (host == "0.0.0.0" || host.empty())
	{
		serverAddr.sin_addr.s_addr = INADDR_ANY;
	}
	else
	{
		if (inet_pton(AF_INET, host.c_str(), &serverAddr.sin_addr) <= 0)
		{
			std::cerr << "Invalid address: " << host << std::endl;
			close(sockfd);
			return -1;
		}
	}

	// Step 4: Bind Socket to Address
	if (bind(sockfd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) < 0)
	{
		std::cerr << "bind() failed for " << host << ":" << port
					<< " - " << strerror(errno) << std::endl;

		if (errno == EADDRINUSE)
		{
			std::cerr << "  Hint: Another process is using this port. "
						<< "Try 'lsof -i :" << port << "' to find it." << std::endl;
		}
		else if (errno == EACCES)
		{
			std::cerr << "  Hint: Ports below 1024 require root privileges. "
						<< "Try a port >= 1024 or run as root." << std::endl;
		}

		close(sockfd);
		return -1;
	}

	std::cout << "  [3/5] bind() to " << host << ":" << port << std::endl;

	// Step 5: Set Non-Blocking Mode
	if (!setNonBlocking(sockfd))
	{
		std::cerr << "Failed to set non-blocking mode" << std::endl;
		close(sockfd);
		return -1;
	}

	std::cout << "  [4/5] fcntl() set non-blocking mode" << std::endl;

	// Step 6: Start Listening
	const int BACKLOG = 128;

	if (listen(sockfd, BACKLOG) < 0)
	{
		std::cerr << "listen() failed: " << strerror(errno) << std::endl;
		close(sockfd);
		return -1;
	}

	std::cout << "  [5/5] listen() with backlog=" << BACKLOG << std::endl;

	return sockfd;
}


bool Server::setNonBlocking(int fd)
{
	int flags = fcntl(fd, F_GETFL, 0);

	if (flags < 0)
	{
		std::cerr << "fcntl(F_GETFL) failed: " << strerror(errno) << std::endl;
		return false;
	}

	if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) < 0)
	{
		std::cerr << "fcntl(F_SETFL) failed: " << strerror(errno) << std::endl;
		return false;
	}

	return true;
}


// =================================================================
//  SERVER LIFECYCLE
// =================================================================

void Server::stop()
{
	if (_running)
	{
		std::cout << "\n=== Stopping Server ===" << std::endl;
		_running = false;
	}

	// Close all client connections first
	std::vector<int> clientFds;
	for (std::map<int, ClientInfo>::iterator it = _clients.begin();
			it != _clients.end(); ++it)
	{
		clientFds.push_back(it->first);
	}

	for (size_t i = 0; i < clientFds.size(); ++i)
	{
		closeClientConnection(clientFds[i]);
	}

	// Close epoll
	closeEpoll();

	// Close listening sockets
	closeAllSockets();
}


void Server::closeAllSockets()
{
	for (size_t i = 0; i < _listenSockets.size(); ++i)
	{
		if (_listenSockets[i].fd >= 0)
		{
			std::cout << "Closing socket fd=" << _listenSockets[i].fd
						<< " (" << _listenSockets[i].host
						<< ":" << _listenSockets[i].port << ")" << std::endl;

			close(_listenSockets[i].fd);
			_listenSockets[i].fd = -1;
		}
	}

	_listenSockets.clear();
	_listenFds.clear();
}


// =================================================================
//  GETTERS
// =================================================================

bool Server::isRunning() const
{
	return _running;
}

const std::vector<ListenSocket>& Server::getListenSockets() const
{
	return _listenSockets;
}

int Server::getEpollFd() const
{
	return _epollFd;
}

size_t Server::getClientCount() const
{
	return _clients.size();
}
````

## Updated main.cpp with Step 2.2 Tests

````cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anemet <anemet@student.42luxembourg.lu>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/07 15:54:34 by anemet            #+#    #+#             */
/*   Updated: 2025/12/15 12:00:00 by anemet           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


/*
	=================================================================
		WEBSERV - STEP 2.2: EPOLL EVENT LOOP
	=================================================================

	This step implements the core event loop using Linux's epoll.

	What epoll provides:
	--------------------
	- Efficient monitoring of many file descriptors
	- O(1) event notification (vs O(n) for poll/select)
	- Scales to thousands of concurrent connections

	Run the server:
	---------------
		./webserv                        # Uses default config
		./webserv config/default.conf    # Specific config

	Run unit tests:
	---------------
		./webserv --test

	Test connectivity:
	------------------
		Terminal 1:
			./webserv

		Terminal 2:
			# Basic connection test
			curl -v http://localhost:8080/

			# Multiple connections
			for i in {1..5}; do curl http://localhost:8080/ & done

			# Test with netcat
			echo -e "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n" | nc localhost 8080

			# Check socket is listening
			ss -tuln | grep 8080
*/


#include <iostream>
#include <cstring>
#include <csignal>
#include <cstdlib>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/epoll.h>

#include "Config.hpp"
#include "Server.hpp"


// Global pointer for signal handler
static Server* g_server = NULL;


/*
	Signal Handler
	--------------
	Catches Ctrl+C (SIGINT), Ctrl+\ (SIGQUIT), and SIGTERM
	to allow graceful shutdown.

	Why graceful shutdown matters:
	- Closes all sockets properly
	- Releases system resources
	- Prevents "Address already in use" errors on restart
*/
void signalHandler(int signum)
{
	std::cout << "\n[Signal] Received signal " << signum;
	if (signum == SIGINT)  std::cout << " (SIGINT - Ctrl+C)";
	if (signum == SIGQUIT) std::cout << " (SIGQUIT - Ctrl+\\)";
	if (signum == SIGTERM) std::cout << " (SIGTERM)";
	std::cout << std::endl;

	if (g_server)
	{
		g_server->stop();
	}
}


void setupSignalHandlers()
{
	signal(SIGINT, signalHandler);
	signal(SIGQUIT, signalHandler);
	signal(SIGTERM, signalHandler);
}


void printUsage(const char* programName)
{
	std::cout << "Usage: " << programName << " [config_file]" << std::endl;
	std::cout << "       " << programName << " --test" << std::endl;
	std::cout << std::endl;
	std::cout << "Options:" << std::endl;
	std::cout << "  config_file   Path to configuration file" << std::endl;
	std::cout << "  --test        Run unit tests" << std::endl;
	std::cout << std::endl;
	std::cout << "If no config file is specified, uses config/default.conf" << std::endl;
}


/*
	=================================================================
		UNIT TESTS FOR STEP 2.2: EPOLL EVENT LOOP
	=================================================================
*/

// Test counters
static int g_testsRun = 0;
static int g_testsPassed = 0;
static int g_testsFailed = 0;

// Colors for output
#define COLOR_GREEN  "\033[32m"
#define COLOR_RED    "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_CYAN   "\033[36m"
#define COLOR_RESET  "\033[0m"

#define TEST_ASSERT(condition, message) \
	do { \
		g_testsRun++; \
		if (condition) { \
			g_testsPassed++; \
			std::cout << COLOR_GREEN << "[PASS] " << COLOR_RESET << message << std::endl; \
		} else { \
			g_testsFailed++; \
			std::cout << COLOR_RED << "[FAIL] " << COLOR_RESET << message << std::endl; \
		} \
	} while (0)


/*
	Test 1: Epoll Creation
	Verify that epoll instance is created successfully
*/
void testEpollCreation()
{
	std::cout << "\n" << COLOR_CYAN << "=== Test 1: Epoll Creation ===" << COLOR_RESET << std::endl;

	try
	{
		Config config;
		config.parseFile("config/default.conf");

		Server server(config);
		bool initResult = server.init();

		TEST_ASSERT(initResult, "Server.init() succeeds with epoll");
		TEST_ASSERT(server.getEpollFd() >= 0, "Epoll file descriptor is valid (>= 0)");

		int epollFd = server.getEpollFd();
		std::cout << "  Epoll fd = " << epollFd << std::endl;

		server.stop();
		TEST_ASSERT(server.getEpollFd() < 0, "Epoll fd is -1 after stop()");
	}
	catch (const std::exception& e)
	{
		TEST_ASSERT(false, std::string("Exception: ") + e.what());
	}
}


/*
	Test 2: Listening Sockets in Epoll
	Verify that listening sockets are added to epoll
*/
void testListenSocketsInEpoll()
{
	std::cout << "\n" << COLOR_CYAN << "=== Test 2: Listening Sockets in Epoll ===" << COLOR_RESET << std::endl;

	try
	{
		Config config;
		config.parseFile("config/default.conf");

		Server server(config);
		server.init();

		const std::vector<ListenSocket>& sockets = server.getListenSockets();
		TEST_ASSERT(!sockets.empty(), "At least one listening socket exists");

		// Each socket should be added to epoll (we can verify by checking
		// that epoll_ctl doesn't fail - already done in init())
		for (size_t i = 0; i < sockets.size(); ++i)
		{
			std::stringstream msg;
			msg << "Listen socket fd=" << sockets[i].fd
				<< " on port " << sockets[i].port << " is valid";
			TEST_ASSERT(sockets[i].fd >= 0, msg.str());
		}

		server.stop();
	}
	catch (const std::exception& e)// filepath: /home/anemet/webserv/src/main.cpp
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anemet <anemet@student.42luxembourg.lu>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/07 15:54:34 by anemet            #+#    #+#             */
/*   Updated: 2025/12/15 12:00:00 by anemet           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


/*
	=================================================================
		WEBSERV - STEP 2.2: EPOLL EVENT LOOP
	=================================================================

	This step implements the core event loop using Linux's epoll.

	What epoll provides:
	--------------------
	- Efficient monitoring of many file descriptors
	- O(1) event notification (vs O(n) for poll/select)
	- Scales to thousands of concurrent connections

	Run the server:
	---------------
		./webserv                        # Uses default config
		./webserv config/default.conf    # Specific config

	Run unit tests:
	---------------
		./webserv --test

	Test connectivity:
	------------------
		Terminal 1:
			./webserv

		Terminal 2:
			# Basic connection test
			curl -v http://localhost:8080/

			# Multiple connections
			for i in {1..5}; do curl http://localhost:8080/ & done

			# Test with netcat
			echo -e "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n" | nc localhost 8080

			# Check socket is listening
			ss -tuln | grep 8080
*/


#include <iostream>
#include <cstring>
#include <csignal>
#include <cstdlib>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/epoll.h>

#include "Config.hpp"
#include "Server.hpp"


// Global pointer for signal handler
static Server* g_server = NULL;


/*
	Signal Handler
	--------------
	Catches Ctrl+C (SIGINT), Ctrl+\ (SIGQUIT), and SIGTERM
	to allow graceful shutdown.

	Why graceful shutdown matters:
	- Closes all sockets properly
	- Releases system resources
	- Prevents "Address already in use" errors on restart
*/
void signalHandler(int signum)
{
	std::cout << "\n[Signal] Received signal " << signum;
	if (signum == SIGINT)  std::cout << " (SIGINT - Ctrl+C)";
	if (signum == SIGQUIT) std::cout << " (SIGQUIT - Ctrl+\\)";
	if (signum == SIGTERM) std::cout << " (SIGTERM)";
	std::cout << std::endl;

	if (g_server)
	{
		g_server->stop();
	}
}


void setupSignalHandlers()
{
	signal(SIGINT, signalHandler);
	signal(SIGQUIT, signalHandler);
	signal(SIGTERM, signalHandler);
}


void printUsage(const char* programName)
{
	std::cout << "Usage: " << programName << " [config_file]" << std::endl;
	std::cout << "       " << programName << " --test" << std::endl;
	std::cout << std::endl;
	std::cout << "Options:" << std::endl;
	std::cout << "  config_file   Path to configuration file" << std::endl;
	std::cout << "  --test        Run unit tests" << std::endl;
	std::cout << std::endl;
	std::cout << "If no config file is specified, uses config/default.conf" << std::endl;
}


/*
	=================================================================
		UNIT TESTS FOR STEP 2.2: EPOLL EVENT LOOP
	=================================================================
*/

// Test counters
static int g_testsRun = 0;
static int g_testsPassed = 0;
static int g_testsFailed = 0;

// Colors for output
#define COLOR_GREEN  "\033[32m"
#define COLOR_RED    "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_CYAN   "\033[36m"
#define COLOR_RESET  "\033[0m"

#define TEST_ASSERT(condition, message) \
	do { \
		g_testsRun++; \
		if (condition) { \
			g_testsPassed++; \
			std::cout << COLOR_GREEN << "[PASS] " << COLOR_RESET << message << std::endl; \
		} else { \
			g_testsFailed++; \
			std::cout << COLOR_RED << "[FAIL] " << COLOR_RESET << message << std::endl; \
		} \
	} while (0)


/*
	Test 1: Epoll Creation
	Verify that epoll instance is created successfully
*/
void testEpollCreation()
{
	std::cout << "\n" << COLOR_CYAN << "=== Test 1: Epoll Creation ===" << COLOR_RESET << std::endl;

	try
	{
		Config config;
		config.parseFile("config/default.conf");

		Server server(config);
		bool initResult = server.init();

		TEST_ASSERT(initResult, "Server.init() succeeds with epoll");
		TEST_ASSERT(server.getEpollFd() >= 0, "Epoll file descriptor is valid (>= 0)");

		int epollFd = server.getEpollFd();
		std::cout << "  Epoll fd = " << epollFd << std::endl;

		server.stop();
		TEST_ASSERT(server.getEpollFd() < 0, "Epoll fd is -1 after stop()");
	}
	catch (const std::exception& e)
	{
		TEST_ASSERT(false, std::string("Exception: ") + e.what());
	}
}


/*
	Test 2: Listening Sockets in Epoll
	Verify that listening sockets are added to epoll
*/
void testListenSocketsInEpoll()
{
	std::cout << "\n" << COLOR_CYAN << "=== Test 2: Listening Sockets in Epoll ===" << COLOR_RESET << std::endl;

	try
	{
		Config config;
		config.parseFile("config/default.conf");

		Server server(config);
		server.init();

		const std::vector<ListenSocket>& sockets = server.getListenSockets();
		TEST_ASSERT(!sockets.empty(), "At least one listening socket exists");

		// Each socket should be added to epoll (we can verify by checking
		// that epoll_ctl doesn't fail - already done in init())
		for (size_t i = 0; i < sockets.size(); ++i)
		{
			std::stringstream msg;
			msg << "Listen socket fd=" << sockets[i].fd
				<< " on port " << sockets[i].port << " is valid";
			TEST_ASSERT(sockets[i].fd >= 0, msg.str());
		}

		server.stop();
	}
	catch (const std::exception& e)
